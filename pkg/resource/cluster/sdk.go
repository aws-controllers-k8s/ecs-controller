// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package cluster

import (
	"context"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strings"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcondition "github.com/aws-controllers-k8s/runtime/pkg/condition"
	ackerr "github.com/aws-controllers-k8s/runtime/pkg/errors"
	ackrequeue "github.com/aws-controllers-k8s/runtime/pkg/requeue"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/ecs"
	svcsdktypes "github.com/aws/aws-sdk-go-v2/service/ecs/types"
	smithy "github.com/aws/smithy-go"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	svcapitypes "github.com/aws-controllers-k8s/ecs-controller/apis/v1alpha1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
	_ = strings.ToLower("")
	_ = &svcsdk.Client{}
	_ = &svcapitypes.Cluster{}
	_ = ackv1alpha1.AWSAccountID("")
	_ = &ackerr.NotFound
	_ = &ackcondition.NotManagedMessage
	_ = &reflect.Value{}
	_ = fmt.Sprintf("")
	_ = &ackrequeue.NoRequeue{}
	_ = &aws.Config{}
)

// sdkFind returns SDK-specific information about a supplied resource
func (rm *resourceManager) sdkFind(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkFind")
	defer func() {
		exit(err)
	}()
	// If any required fields in the input shape are missing, AWS resource is
	// not created yet. Return NotFound here to indicate to callers that the
	// resource isn't yet created.
	if rm.requiredFieldsMissingFromReadManyInput(r) {
		return nil, ackerr.NotFound
	}

	input, err := rm.newListRequestPayload(r)
	if err != nil {
		return nil, err
	}
	input.Clusters = []string{*r.ko.Spec.Name}
	input.Include = []svcsdktypes.ClusterField{
		svcsdktypes.ClusterFieldAttachments,
		svcsdktypes.ClusterFieldConfigurations,
		svcsdktypes.ClusterFieldSettings,
		svcsdktypes.ClusterFieldStatistics,
		svcsdktypes.ClusterFieldTags,
	}
	var resp *svcsdk.DescribeClustersOutput
	resp, err = rm.sdkapi.DescribeClusters(ctx, input)
	rm.metrics.RecordAPICall("READ_MANY", "DescribeClusters", err)
	if err != nil {
		var awsErr smithy.APIError
		if errors.As(err, &awsErr) && awsErr.ErrorCode() == "UNKNOWN" {
			return nil, ackerr.NotFound
		}
		return nil, err
	}

	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	found := false
	for _, elem := range resp.Clusters {
		activeServicesCountCopy := int64(elem.ActiveServicesCount)
		ko.Status.ActiveServicesCount = &activeServicesCountCopy
		if elem.Attachments != nil {
			f1 := []*svcapitypes.Attachment{}
			for _, f1iter := range elem.Attachments {
				f1elem := &svcapitypes.Attachment{}
				if f1iter.Details != nil {
					f1elemf0 := []*svcapitypes.KeyValuePair{}
					for _, f1elemf0iter := range f1iter.Details {
						f1elemf0elem := &svcapitypes.KeyValuePair{}
						if f1elemf0iter.Name != nil {
							f1elemf0elem.Name = f1elemf0iter.Name
						}
						if f1elemf0iter.Value != nil {
							f1elemf0elem.Value = f1elemf0iter.Value
						}
						f1elemf0 = append(f1elemf0, f1elemf0elem)
					}
					f1elem.Details = f1elemf0
				}
				if f1iter.Id != nil {
					f1elem.ID = f1iter.Id
				}
				if f1iter.Status != nil {
					f1elem.Status = f1iter.Status
				}
				if f1iter.Type != nil {
					f1elem.Type = f1iter.Type
				}
				f1 = append(f1, f1elem)
			}
			ko.Status.Attachments = f1
		} else {
			ko.Status.Attachments = nil
		}
		if elem.AttachmentsStatus != nil {
			ko.Status.AttachmentsStatus = elem.AttachmentsStatus
		} else {
			ko.Status.AttachmentsStatus = nil
		}
		if elem.CapacityProviders != nil {
			ko.Spec.CapacityProviders = aws.StringSlice(elem.CapacityProviders)
		} else {
			ko.Spec.CapacityProviders = nil
		}
		if elem.ClusterArn != nil {
			if ko.Status.ACKResourceMetadata == nil {
				ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
			}
			tmpARN := ackv1alpha1.AWSResourceName(*elem.ClusterArn)
			ko.Status.ACKResourceMetadata.ARN = &tmpARN
		}
		if elem.ClusterName != nil {
			if ko.Spec.Name != nil {
				if *elem.ClusterName != *ko.Spec.Name {
					continue
				}
			}
			ko.Spec.Name = elem.ClusterName
		} else {
			ko.Spec.Name = nil
		}
		if elem.Configuration != nil {
			f6 := &svcapitypes.ClusterConfiguration{}
			if elem.Configuration.ExecuteCommandConfiguration != nil {
				f6f0 := &svcapitypes.ExecuteCommandConfiguration{}
				if elem.Configuration.ExecuteCommandConfiguration.KmsKeyId != nil {
					f6f0.KMSKeyID = elem.Configuration.ExecuteCommandConfiguration.KmsKeyId
				}
				if elem.Configuration.ExecuteCommandConfiguration.LogConfiguration != nil {
					f6f0f1 := &svcapitypes.ExecuteCommandLogConfiguration{}
					f6f0f1.CloudWatchEncryptionEnabled = &elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled
					if elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName != nil {
						f6f0f1.CloudWatchLogGroupName = elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName
					}
					if elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName != nil {
						f6f0f1.S3BucketName = elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName
					}
					f6f0f1.S3EncryptionEnabled = &elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled
					if elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix != nil {
						f6f0f1.S3KeyPrefix = elem.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix
					}
					f6f0.LogConfiguration = f6f0f1
				}
				if elem.Configuration.ExecuteCommandConfiguration.Logging != "" {
					f6f0.Logging = aws.String(string(elem.Configuration.ExecuteCommandConfiguration.Logging))
				}
				f6.ExecuteCommandConfiguration = f6f0
			}
			ko.Spec.Configuration = f6
		} else {
			ko.Spec.Configuration = nil
		}
		if elem.DefaultCapacityProviderStrategy != nil {
			f7 := []*svcapitypes.CapacityProviderStrategyItem{}
			for _, f7iter := range elem.DefaultCapacityProviderStrategy {
				f7elem := &svcapitypes.CapacityProviderStrategyItem{}
				baseCopy := int64(f7iter.Base)
				f7elem.Base = &baseCopy
				if f7iter.CapacityProvider != nil {
					f7elem.CapacityProvider = f7iter.CapacityProvider
				}
				weightCopy := int64(f7iter.Weight)
				f7elem.Weight = &weightCopy
				f7 = append(f7, f7elem)
			}
			ko.Spec.DefaultCapacityProviderStrategy = f7
		} else {
			ko.Spec.DefaultCapacityProviderStrategy = nil
		}
		pendingTasksCountCopy := int64(elem.PendingTasksCount)
		ko.Status.PendingTasksCount = &pendingTasksCountCopy
		registeredContainerInstancesCountCopy := int64(elem.RegisteredContainerInstancesCount)
		ko.Status.RegisteredContainerInstancesCount = &registeredContainerInstancesCountCopy
		runningTasksCountCopy := int64(elem.RunningTasksCount)
		ko.Status.RunningTasksCount = &runningTasksCountCopy
		if elem.ServiceConnectDefaults != nil {
			f11 := &svcapitypes.ClusterServiceConnectDefaultsRequest{}
			if elem.ServiceConnectDefaults.Namespace != nil {
				f11.Namespace = elem.ServiceConnectDefaults.Namespace
			}
			ko.Spec.ServiceConnectDefaults = f11
		} else {
			ko.Spec.ServiceConnectDefaults = nil
		}
		if elem.Settings != nil {
			f12 := []*svcapitypes.ClusterSetting{}
			for _, f12iter := range elem.Settings {
				f12elem := &svcapitypes.ClusterSetting{}
				if f12iter.Name != "" {
					f12elem.Name = aws.String(string(f12iter.Name))
				}
				if f12iter.Value != nil {
					f12elem.Value = f12iter.Value
				}
				f12 = append(f12, f12elem)
			}
			ko.Spec.Settings = f12
		} else {
			ko.Spec.Settings = nil
		}
		if elem.Statistics != nil {
			f13 := []*svcapitypes.KeyValuePair{}
			for _, f13iter := range elem.Statistics {
				f13elem := &svcapitypes.KeyValuePair{}
				if f13iter.Name != nil {
					f13elem.Name = f13iter.Name
				}
				if f13iter.Value != nil {
					f13elem.Value = f13iter.Value
				}
				f13 = append(f13, f13elem)
			}
			ko.Status.Statistics = f13
		} else {
			ko.Status.Statistics = nil
		}
		if elem.Status != nil {
			ko.Status.Status = elem.Status
		} else {
			ko.Status.Status = nil
		}
		if elem.Tags != nil {
			f15 := []*svcapitypes.Tag{}
			for _, f15iter := range elem.Tags {
				f15elem := &svcapitypes.Tag{}
				if f15iter.Key != nil {
					f15elem.Key = f15iter.Key
				}
				if f15iter.Value != nil {
					f15elem.Value = f15iter.Value
				}
				f15 = append(f15, f15elem)
			}
			ko.Spec.Tags = f15
		} else {
			ko.Spec.Tags = nil
		}
		found = true
		break
	}
	if !found {
		return nil, ackerr.NotFound
	}

	rm.setStatusDefaults(ko)
	// Behind the scenes of ECS - when you delete an existing cluster, it
	// status will be set to INACTIVE and the resource will remain "existing"
	// for some time. As you might understand from the Go snipet below, yes,
	// we can "create" cluster that already exists (but are in INACTIVE) state.
	//
	// From ECS docs, INACTIVE: The cluster has been deleted. Clusters with an
	// INACTIVE status may remain discoverable in your account for a period of
	// time. However, this behavior is subject to change in the future. We don't
	// recommend that you rely on INACTIVE clusters persisting.
	//
	// Possible statuses: ACTIVE, PROVISIONING, DEPROVISIONING, FAILED, INACTIVE
	if ko.Status.Status != nil && *ko.Status.Status == "INACTIVE" {
		// Returning a NotFound error will trigger the create path.
		return nil, ackerr.NotFound
	}
	return &resource{ko}, nil
}

// requiredFieldsMissingFromReadManyInput returns true if there are any fields
// for the ReadMany Input shape that are required but not present in the
// resource's Spec or Status
func (rm *resourceManager) requiredFieldsMissingFromReadManyInput(
	r *resource,
) bool {
	return false
}

// newListRequestPayload returns SDK-specific struct for the HTTP request
// payload of the List API call for the resource
func (rm *resourceManager) newListRequestPayload(
	r *resource,
) (*svcsdk.DescribeClustersInput, error) {
	res := &svcsdk.DescribeClustersInput{}

	return res, nil
}

// sdkCreate creates the supplied resource in the backend AWS service API and
// returns a copy of the resource with resource fields (in both Spec and
// Status) filled in with values from the CREATE API operation's Output shape.
func (rm *resourceManager) sdkCreate(
	ctx context.Context,
	desired *resource,
) (created *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkCreate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newCreateRequestPayload(ctx, desired)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.CreateClusterOutput
	_ = resp
	resp, err = rm.sdkapi.CreateCluster(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "CreateCluster", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	activeServicesCountCopy := int64(resp.Cluster.ActiveServicesCount)
	ko.Status.ActiveServicesCount = &activeServicesCountCopy
	if resp.Cluster.Attachments != nil {
		f1 := []*svcapitypes.Attachment{}
		for _, f1iter := range resp.Cluster.Attachments {
			f1elem := &svcapitypes.Attachment{}
			if f1iter.Details != nil {
				f1elemf0 := []*svcapitypes.KeyValuePair{}
				for _, f1elemf0iter := range f1iter.Details {
					f1elemf0elem := &svcapitypes.KeyValuePair{}
					if f1elemf0iter.Name != nil {
						f1elemf0elem.Name = f1elemf0iter.Name
					}
					if f1elemf0iter.Value != nil {
						f1elemf0elem.Value = f1elemf0iter.Value
					}
					f1elemf0 = append(f1elemf0, f1elemf0elem)
				}
				f1elem.Details = f1elemf0
			}
			if f1iter.Id != nil {
				f1elem.ID = f1iter.Id
			}
			if f1iter.Status != nil {
				f1elem.Status = f1iter.Status
			}
			if f1iter.Type != nil {
				f1elem.Type = f1iter.Type
			}
			f1 = append(f1, f1elem)
		}
		ko.Status.Attachments = f1
	} else {
		ko.Status.Attachments = nil
	}
	if resp.Cluster.AttachmentsStatus != nil {
		ko.Status.AttachmentsStatus = resp.Cluster.AttachmentsStatus
	} else {
		ko.Status.AttachmentsStatus = nil
	}
	if resp.Cluster.CapacityProviders != nil {
		ko.Spec.CapacityProviders = aws.StringSlice(resp.Cluster.CapacityProviders)
	} else {
		ko.Spec.CapacityProviders = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.Cluster.ClusterArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.Cluster.ClusterArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.Cluster.ClusterName != nil {
		ko.Spec.Name = resp.Cluster.ClusterName
	} else {
		ko.Spec.Name = nil
	}
	if resp.Cluster.Configuration != nil {
		f6 := &svcapitypes.ClusterConfiguration{}
		if resp.Cluster.Configuration.ExecuteCommandConfiguration != nil {
			f6f0 := &svcapitypes.ExecuteCommandConfiguration{}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.KmsKeyId != nil {
				f6f0.KMSKeyID = resp.Cluster.Configuration.ExecuteCommandConfiguration.KmsKeyId
			}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration != nil {
				f6f0f1 := &svcapitypes.ExecuteCommandLogConfiguration{}
				f6f0f1.CloudWatchEncryptionEnabled = &resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName != nil {
					f6f0f1.CloudWatchLogGroupName = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName
				}
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName != nil {
					f6f0f1.S3BucketName = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName
				}
				f6f0f1.S3EncryptionEnabled = &resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix != nil {
					f6f0f1.S3KeyPrefix = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix
				}
				f6f0.LogConfiguration = f6f0f1
			}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.Logging != "" {
				f6f0.Logging = aws.String(string(resp.Cluster.Configuration.ExecuteCommandConfiguration.Logging))
			}
			f6.ExecuteCommandConfiguration = f6f0
		}
		ko.Spec.Configuration = f6
	} else {
		ko.Spec.Configuration = nil
	}
	if resp.Cluster.DefaultCapacityProviderStrategy != nil {
		f7 := []*svcapitypes.CapacityProviderStrategyItem{}
		for _, f7iter := range resp.Cluster.DefaultCapacityProviderStrategy {
			f7elem := &svcapitypes.CapacityProviderStrategyItem{}
			baseCopy := int64(f7iter.Base)
			f7elem.Base = &baseCopy
			if f7iter.CapacityProvider != nil {
				f7elem.CapacityProvider = f7iter.CapacityProvider
			}
			weightCopy := int64(f7iter.Weight)
			f7elem.Weight = &weightCopy
			f7 = append(f7, f7elem)
		}
		ko.Spec.DefaultCapacityProviderStrategy = f7
	} else {
		ko.Spec.DefaultCapacityProviderStrategy = nil
	}
	pendingTasksCountCopy := int64(resp.Cluster.PendingTasksCount)
	ko.Status.PendingTasksCount = &pendingTasksCountCopy
	registeredContainerInstancesCountCopy := int64(resp.Cluster.RegisteredContainerInstancesCount)
	ko.Status.RegisteredContainerInstancesCount = &registeredContainerInstancesCountCopy
	runningTasksCountCopy := int64(resp.Cluster.RunningTasksCount)
	ko.Status.RunningTasksCount = &runningTasksCountCopy
	if resp.Cluster.ServiceConnectDefaults != nil {
		f11 := &svcapitypes.ClusterServiceConnectDefaultsRequest{}
		if resp.Cluster.ServiceConnectDefaults.Namespace != nil {
			f11.Namespace = resp.Cluster.ServiceConnectDefaults.Namespace
		}
		ko.Spec.ServiceConnectDefaults = f11
	} else {
		ko.Spec.ServiceConnectDefaults = nil
	}
	if resp.Cluster.Settings != nil {
		f12 := []*svcapitypes.ClusterSetting{}
		for _, f12iter := range resp.Cluster.Settings {
			f12elem := &svcapitypes.ClusterSetting{}
			if f12iter.Name != "" {
				f12elem.Name = aws.String(string(f12iter.Name))
			}
			if f12iter.Value != nil {
				f12elem.Value = f12iter.Value
			}
			f12 = append(f12, f12elem)
		}
		ko.Spec.Settings = f12
	} else {
		ko.Spec.Settings = nil
	}
	if resp.Cluster.Statistics != nil {
		f13 := []*svcapitypes.KeyValuePair{}
		for _, f13iter := range resp.Cluster.Statistics {
			f13elem := &svcapitypes.KeyValuePair{}
			if f13iter.Name != nil {
				f13elem.Name = f13iter.Name
			}
			if f13iter.Value != nil {
				f13elem.Value = f13iter.Value
			}
			f13 = append(f13, f13elem)
		}
		ko.Status.Statistics = f13
	} else {
		ko.Status.Statistics = nil
	}
	if resp.Cluster.Status != nil {
		ko.Status.Status = resp.Cluster.Status
	} else {
		ko.Status.Status = nil
	}
	if resp.Cluster.Tags != nil {
		f15 := []*svcapitypes.Tag{}
		for _, f15iter := range resp.Cluster.Tags {
			f15elem := &svcapitypes.Tag{}
			if f15iter.Key != nil {
				f15elem.Key = f15iter.Key
			}
			if f15iter.Value != nil {
				f15elem.Value = f15iter.Value
			}
			f15 = append(f15, f15elem)
		}
		ko.Spec.Tags = f15
	} else {
		ko.Spec.Tags = nil
	}

	rm.setStatusDefaults(ko)
	// We expect the cluster to be in 'creating' status since we just issued
	// the call to create it, but I suppose it doesn't hurt to check here.
	if !clusterActive(&resource{ko}) {
		// Setting resource synced condition to false will trigger a requeue of
		// the resource. No need to return a requeue error here.
		ackcondition.SetSynced(&resource{ko}, corev1.ConditionFalse, nil, nil)
		return &resource{ko}, nil
	}

	return &resource{ko}, nil
}

// newCreateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Create API call for the resource
func (rm *resourceManager) newCreateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.CreateClusterInput, error) {
	res := &svcsdk.CreateClusterInput{}

	if r.ko.Spec.CapacityProviders != nil {
		res.CapacityProviders = aws.ToStringSlice(r.ko.Spec.CapacityProviders)
	}
	if r.ko.Spec.Name != nil {
		res.ClusterName = r.ko.Spec.Name
	}
	if r.ko.Spec.Configuration != nil {
		f2 := &svcsdktypes.ClusterConfiguration{}
		if r.ko.Spec.Configuration.ExecuteCommandConfiguration != nil {
			f2f0 := &svcsdktypes.ExecuteCommandConfiguration{}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.KMSKeyID != nil {
				f2f0.KmsKeyId = r.ko.Spec.Configuration.ExecuteCommandConfiguration.KMSKeyID
			}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration != nil {
				f2f0f1 := &svcsdktypes.ExecuteCommandLogConfiguration{}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled != nil {
					f2f0f1.CloudWatchEncryptionEnabled = *r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName != nil {
					f2f0f1.CloudWatchLogGroupName = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName != nil {
					f2f0f1.S3BucketName = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled != nil {
					f2f0f1.S3EncryptionEnabled = *r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix != nil {
					f2f0f1.S3KeyPrefix = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix
				}
				f2f0.LogConfiguration = f2f0f1
			}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.Logging != nil {
				f2f0.Logging = svcsdktypes.ExecuteCommandLogging(*r.ko.Spec.Configuration.ExecuteCommandConfiguration.Logging)
			}
			f2.ExecuteCommandConfiguration = f2f0
		}
		res.Configuration = f2
	}
	if r.ko.Spec.DefaultCapacityProviderStrategy != nil {
		f3 := []svcsdktypes.CapacityProviderStrategyItem{}
		for _, f3iter := range r.ko.Spec.DefaultCapacityProviderStrategy {
			f3elem := &svcsdktypes.CapacityProviderStrategyItem{}
			if f3iter.Base != nil {
				baseCopy0 := *f3iter.Base
				if baseCopy0 > math.MaxInt32 || baseCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field base is of type int32")
				}
				baseCopy := int32(baseCopy0)
				f3elem.Base = baseCopy
			}
			if f3iter.CapacityProvider != nil {
				f3elem.CapacityProvider = f3iter.CapacityProvider
			}
			if f3iter.Weight != nil {
				weightCopy0 := *f3iter.Weight
				if weightCopy0 > math.MaxInt32 || weightCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field weight is of type int32")
				}
				weightCopy := int32(weightCopy0)
				f3elem.Weight = weightCopy
			}
			f3 = append(f3, *f3elem)
		}
		res.DefaultCapacityProviderStrategy = f3
	}
	if r.ko.Spec.ServiceConnectDefaults != nil {
		f4 := &svcsdktypes.ClusterServiceConnectDefaultsRequest{}
		if r.ko.Spec.ServiceConnectDefaults.Namespace != nil {
			f4.Namespace = r.ko.Spec.ServiceConnectDefaults.Namespace
		}
		res.ServiceConnectDefaults = f4
	}
	if r.ko.Spec.Settings != nil {
		f5 := []svcsdktypes.ClusterSetting{}
		for _, f5iter := range r.ko.Spec.Settings {
			f5elem := &svcsdktypes.ClusterSetting{}
			if f5iter.Name != nil {
				f5elem.Name = svcsdktypes.ClusterSettingName(*f5iter.Name)
			}
			if f5iter.Value != nil {
				f5elem.Value = f5iter.Value
			}
			f5 = append(f5, *f5elem)
		}
		res.Settings = f5
	}
	if r.ko.Spec.Tags != nil {
		f6 := []svcsdktypes.Tag{}
		for _, f6iter := range r.ko.Spec.Tags {
			f6elem := &svcsdktypes.Tag{}
			if f6iter.Key != nil {
				f6elem.Key = f6iter.Key
			}
			if f6iter.Value != nil {
				f6elem.Value = f6iter.Value
			}
			f6 = append(f6, *f6elem)
		}
		res.Tags = f6
	}

	return res, nil
}

// sdkUpdate patches the supplied resource in the backend AWS service API and
// returns a new resource with updated fields.
func (rm *resourceManager) sdkUpdate(
	ctx context.Context,
	desired *resource,
	latest *resource,
	delta *ackcompare.Delta,
) (updated *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkUpdate")
	defer func() {
		exit(err)
	}()
	if delta.DifferentAt("Spec.Tags") {
		err := syncTags(
			ctx, rm.sdkapi, rm.metrics,
			string(*desired.ko.Status.ACKResourceMetadata.ARN),
			desired.ko.Spec.Tags, latest.ko.Spec.Tags,
		)
		if err != nil {
			return nil, err
		}
	}
	if !delta.DifferentExcept("Spec.Tags") {
		return desired, nil
	}
	input, err := rm.newUpdateRequestPayload(ctx, desired, delta)
	if err != nil {
		return nil, err
	}
	input.Cluster = desired.ko.Spec.Name

	var resp *svcsdk.UpdateClusterOutput
	_ = resp
	resp, err = rm.sdkapi.UpdateCluster(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "UpdateCluster", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	activeServicesCountCopy := int64(resp.Cluster.ActiveServicesCount)
	ko.Status.ActiveServicesCount = &activeServicesCountCopy
	if resp.Cluster.Attachments != nil {
		f1 := []*svcapitypes.Attachment{}
		for _, f1iter := range resp.Cluster.Attachments {
			f1elem := &svcapitypes.Attachment{}
			if f1iter.Details != nil {
				f1elemf0 := []*svcapitypes.KeyValuePair{}
				for _, f1elemf0iter := range f1iter.Details {
					f1elemf0elem := &svcapitypes.KeyValuePair{}
					if f1elemf0iter.Name != nil {
						f1elemf0elem.Name = f1elemf0iter.Name
					}
					if f1elemf0iter.Value != nil {
						f1elemf0elem.Value = f1elemf0iter.Value
					}
					f1elemf0 = append(f1elemf0, f1elemf0elem)
				}
				f1elem.Details = f1elemf0
			}
			if f1iter.Id != nil {
				f1elem.ID = f1iter.Id
			}
			if f1iter.Status != nil {
				f1elem.Status = f1iter.Status
			}
			if f1iter.Type != nil {
				f1elem.Type = f1iter.Type
			}
			f1 = append(f1, f1elem)
		}
		ko.Status.Attachments = f1
	} else {
		ko.Status.Attachments = nil
	}
	if resp.Cluster.AttachmentsStatus != nil {
		ko.Status.AttachmentsStatus = resp.Cluster.AttachmentsStatus
	} else {
		ko.Status.AttachmentsStatus = nil
	}
	if resp.Cluster.CapacityProviders != nil {
		ko.Spec.CapacityProviders = aws.StringSlice(resp.Cluster.CapacityProviders)
	} else {
		ko.Spec.CapacityProviders = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.Cluster.ClusterArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.Cluster.ClusterArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.Cluster.ClusterName != nil {
		ko.Spec.Name = resp.Cluster.ClusterName
	} else {
		ko.Spec.Name = nil
	}
	if resp.Cluster.Configuration != nil {
		f6 := &svcapitypes.ClusterConfiguration{}
		if resp.Cluster.Configuration.ExecuteCommandConfiguration != nil {
			f6f0 := &svcapitypes.ExecuteCommandConfiguration{}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.KmsKeyId != nil {
				f6f0.KMSKeyID = resp.Cluster.Configuration.ExecuteCommandConfiguration.KmsKeyId
			}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration != nil {
				f6f0f1 := &svcapitypes.ExecuteCommandLogConfiguration{}
				f6f0f1.CloudWatchEncryptionEnabled = &resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName != nil {
					f6f0f1.CloudWatchLogGroupName = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName
				}
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName != nil {
					f6f0f1.S3BucketName = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName
				}
				f6f0f1.S3EncryptionEnabled = &resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled
				if resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix != nil {
					f6f0f1.S3KeyPrefix = resp.Cluster.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix
				}
				f6f0.LogConfiguration = f6f0f1
			}
			if resp.Cluster.Configuration.ExecuteCommandConfiguration.Logging != "" {
				f6f0.Logging = aws.String(string(resp.Cluster.Configuration.ExecuteCommandConfiguration.Logging))
			}
			f6.ExecuteCommandConfiguration = f6f0
		}
		ko.Spec.Configuration = f6
	} else {
		ko.Spec.Configuration = nil
	}
	if resp.Cluster.DefaultCapacityProviderStrategy != nil {
		f7 := []*svcapitypes.CapacityProviderStrategyItem{}
		for _, f7iter := range resp.Cluster.DefaultCapacityProviderStrategy {
			f7elem := &svcapitypes.CapacityProviderStrategyItem{}
			baseCopy := int64(f7iter.Base)
			f7elem.Base = &baseCopy
			if f7iter.CapacityProvider != nil {
				f7elem.CapacityProvider = f7iter.CapacityProvider
			}
			weightCopy := int64(f7iter.Weight)
			f7elem.Weight = &weightCopy
			f7 = append(f7, f7elem)
		}
		ko.Spec.DefaultCapacityProviderStrategy = f7
	} else {
		ko.Spec.DefaultCapacityProviderStrategy = nil
	}
	pendingTasksCountCopy := int64(resp.Cluster.PendingTasksCount)
	ko.Status.PendingTasksCount = &pendingTasksCountCopy
	registeredContainerInstancesCountCopy := int64(resp.Cluster.RegisteredContainerInstancesCount)
	ko.Status.RegisteredContainerInstancesCount = &registeredContainerInstancesCountCopy
	runningTasksCountCopy := int64(resp.Cluster.RunningTasksCount)
	ko.Status.RunningTasksCount = &runningTasksCountCopy
	if resp.Cluster.ServiceConnectDefaults != nil {
		f11 := &svcapitypes.ClusterServiceConnectDefaultsRequest{}
		if resp.Cluster.ServiceConnectDefaults.Namespace != nil {
			f11.Namespace = resp.Cluster.ServiceConnectDefaults.Namespace
		}
		ko.Spec.ServiceConnectDefaults = f11
	} else {
		ko.Spec.ServiceConnectDefaults = nil
	}
	if resp.Cluster.Settings != nil {
		f12 := []*svcapitypes.ClusterSetting{}
		for _, f12iter := range resp.Cluster.Settings {
			f12elem := &svcapitypes.ClusterSetting{}
			if f12iter.Name != "" {
				f12elem.Name = aws.String(string(f12iter.Name))
			}
			if f12iter.Value != nil {
				f12elem.Value = f12iter.Value
			}
			f12 = append(f12, f12elem)
		}
		ko.Spec.Settings = f12
	} else {
		ko.Spec.Settings = nil
	}
	if resp.Cluster.Statistics != nil {
		f13 := []*svcapitypes.KeyValuePair{}
		for _, f13iter := range resp.Cluster.Statistics {
			f13elem := &svcapitypes.KeyValuePair{}
			if f13iter.Name != nil {
				f13elem.Name = f13iter.Name
			}
			if f13iter.Value != nil {
				f13elem.Value = f13iter.Value
			}
			f13 = append(f13, f13elem)
		}
		ko.Status.Statistics = f13
	} else {
		ko.Status.Statistics = nil
	}
	if resp.Cluster.Status != nil {
		ko.Status.Status = resp.Cluster.Status
	} else {
		ko.Status.Status = nil
	}
	if resp.Cluster.Tags != nil {
		f15 := []*svcapitypes.Tag{}
		for _, f15iter := range resp.Cluster.Tags {
			f15elem := &svcapitypes.Tag{}
			if f15iter.Key != nil {
				f15elem.Key = f15iter.Key
			}
			if f15iter.Value != nil {
				f15elem.Value = f15iter.Value
			}
			f15 = append(f15, f15elem)
		}
		ko.Spec.Tags = f15
	} else {
		ko.Spec.Tags = nil
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// newUpdateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Update API call for the resource
func (rm *resourceManager) newUpdateRequestPayload(
	ctx context.Context,
	r *resource,
	delta *ackcompare.Delta,
) (*svcsdk.UpdateClusterInput, error) {
	res := &svcsdk.UpdateClusterInput{}

	if r.ko.Spec.Configuration != nil {
		f1 := &svcsdktypes.ClusterConfiguration{}
		if r.ko.Spec.Configuration.ExecuteCommandConfiguration != nil {
			f1f0 := &svcsdktypes.ExecuteCommandConfiguration{}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.KMSKeyID != nil {
				f1f0.KmsKeyId = r.ko.Spec.Configuration.ExecuteCommandConfiguration.KMSKeyID
			}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration != nil {
				f1f0f1 := &svcsdktypes.ExecuteCommandLogConfiguration{}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled != nil {
					f1f0f1.CloudWatchEncryptionEnabled = *r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchEncryptionEnabled
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName != nil {
					f1f0f1.CloudWatchLogGroupName = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.CloudWatchLogGroupName
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName != nil {
					f1f0f1.S3BucketName = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3BucketName
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled != nil {
					f1f0f1.S3EncryptionEnabled = *r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3EncryptionEnabled
				}
				if r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix != nil {
					f1f0f1.S3KeyPrefix = r.ko.Spec.Configuration.ExecuteCommandConfiguration.LogConfiguration.S3KeyPrefix
				}
				f1f0.LogConfiguration = f1f0f1
			}
			if r.ko.Spec.Configuration.ExecuteCommandConfiguration.Logging != nil {
				f1f0.Logging = svcsdktypes.ExecuteCommandLogging(*r.ko.Spec.Configuration.ExecuteCommandConfiguration.Logging)
			}
			f1.ExecuteCommandConfiguration = f1f0
		}
		res.Configuration = f1
	}
	if r.ko.Spec.ServiceConnectDefaults != nil {
		f2 := &svcsdktypes.ClusterServiceConnectDefaultsRequest{}
		if r.ko.Spec.ServiceConnectDefaults.Namespace != nil {
			f2.Namespace = r.ko.Spec.ServiceConnectDefaults.Namespace
		}
		res.ServiceConnectDefaults = f2
	}
	if r.ko.Spec.Settings != nil {
		f3 := []svcsdktypes.ClusterSetting{}
		for _, f3iter := range r.ko.Spec.Settings {
			f3elem := &svcsdktypes.ClusterSetting{}
			if f3iter.Name != nil {
				f3elem.Name = svcsdktypes.ClusterSettingName(*f3iter.Name)
			}
			if f3iter.Value != nil {
				f3elem.Value = f3iter.Value
			}
			f3 = append(f3, *f3elem)
		}
		res.Settings = f3
	}

	return res, nil
}

// sdkDelete deletes the supplied resource in the backend AWS service API
func (rm *resourceManager) sdkDelete(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkDelete")
	defer func() {
		exit(err)
	}()
	input, err := rm.newDeleteRequestPayload(r)
	if err != nil {
		return nil, err
	}
	input.Cluster = r.ko.Spec.Name
	var resp *svcsdk.DeleteClusterOutput
	_ = resp
	resp, err = rm.sdkapi.DeleteCluster(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "DeleteCluster", err)
	return nil, err
}

// newDeleteRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Delete API call for the resource
func (rm *resourceManager) newDeleteRequestPayload(
	r *resource,
) (*svcsdk.DeleteClusterInput, error) {
	res := &svcsdk.DeleteClusterInput{}

	return res, nil
}

// setStatusDefaults sets default properties into supplied custom resource
func (rm *resourceManager) setStatusDefaults(
	ko *svcapitypes.Cluster,
) {
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if ko.Status.ACKResourceMetadata.Region == nil {
		ko.Status.ACKResourceMetadata.Region = &rm.awsRegion
	}
	if ko.Status.ACKResourceMetadata.OwnerAccountID == nil {
		ko.Status.ACKResourceMetadata.OwnerAccountID = &rm.awsAccountID
	}
	if ko.Status.Conditions == nil {
		ko.Status.Conditions = []*ackv1alpha1.Condition{}
	}
}

// updateConditions returns updated resource, true; if conditions were updated
// else it returns nil, false
func (rm *resourceManager) updateConditions(
	r *resource,
	onSuccess bool,
	err error,
) (*resource, bool) {
	ko := r.ko.DeepCopy()
	rm.setStatusDefaults(ko)

	// Terminal condition
	var terminalCondition *ackv1alpha1.Condition = nil
	var recoverableCondition *ackv1alpha1.Condition = nil
	var syncCondition *ackv1alpha1.Condition = nil
	for _, condition := range ko.Status.Conditions {
		if condition.Type == ackv1alpha1.ConditionTypeTerminal {
			terminalCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeRecoverable {
			recoverableCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeResourceSynced {
			syncCondition = condition
		}
	}
	var termError *ackerr.TerminalError
	if rm.terminalAWSError(err) || err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
		if terminalCondition == nil {
			terminalCondition = &ackv1alpha1.Condition{
				Type: ackv1alpha1.ConditionTypeTerminal,
			}
			ko.Status.Conditions = append(ko.Status.Conditions, terminalCondition)
		}
		var errorMessage = ""
		if err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
			errorMessage = err.Error()
		} else {
			awsErr, _ := ackerr.AWSError(err)
			errorMessage = awsErr.Error()
		}
		terminalCondition.Status = corev1.ConditionTrue
		terminalCondition.Message = &errorMessage
	} else {
		// Clear the terminal condition if no longer present
		if terminalCondition != nil {
			terminalCondition.Status = corev1.ConditionFalse
			terminalCondition.Message = nil
		}
		// Handling Recoverable Conditions
		if err != nil {
			if recoverableCondition == nil {
				// Add a new Condition containing a non-terminal error
				recoverableCondition = &ackv1alpha1.Condition{
					Type: ackv1alpha1.ConditionTypeRecoverable,
				}
				ko.Status.Conditions = append(ko.Status.Conditions, recoverableCondition)
			}
			recoverableCondition.Status = corev1.ConditionTrue
			awsErr, _ := ackerr.AWSError(err)
			errorMessage := err.Error()
			if awsErr != nil {
				errorMessage = awsErr.Error()
			}
			recoverableCondition.Message = &errorMessage
		} else if recoverableCondition != nil {
			recoverableCondition.Status = corev1.ConditionFalse
			recoverableCondition.Message = nil
		}
	}
	// Required to avoid the "declared but not used" error in the default case
	_ = syncCondition
	if terminalCondition != nil || recoverableCondition != nil || syncCondition != nil {
		return &resource{ko}, true // updated
	}
	return nil, false // not updated
}

// terminalAWSError returns awserr, true; if the supplied error is an aws Error type
// and if the exception indicates that it is a Terminal exception
// 'Terminal' exception are specified in generator configuration
func (rm *resourceManager) terminalAWSError(err error) bool {
	if err == nil {
		return false
	}

	var terminalErr smithy.APIError
	if !errors.As(err, &terminalErr) {
		return false
	}
	switch terminalErr.ErrorCode() {
	case "InvalidParameterException":
		return true
	default:
		return false
	}
}
