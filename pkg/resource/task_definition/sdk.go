// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package task_definition

import (
	"context"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strings"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcondition "github.com/aws-controllers-k8s/runtime/pkg/condition"
	ackerr "github.com/aws-controllers-k8s/runtime/pkg/errors"
	ackrequeue "github.com/aws-controllers-k8s/runtime/pkg/requeue"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/ecs"
	svcsdktypes "github.com/aws/aws-sdk-go-v2/service/ecs/types"
	smithy "github.com/aws/smithy-go"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	svcapitypes "github.com/aws-controllers-k8s/ecs-controller/apis/v1alpha1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
	_ = strings.ToLower("")
	_ = &svcsdk.Client{}
	_ = &svcapitypes.TaskDefinition{}
	_ = ackv1alpha1.AWSAccountID("")
	_ = &ackerr.NotFound
	_ = &ackcondition.NotManagedMessage
	_ = &reflect.Value{}
	_ = fmt.Sprintf("")
	_ = &ackrequeue.NoRequeue{}
	_ = &aws.Config{}
)

// sdkFind returns SDK-specific information about a supplied resource
func (rm *resourceManager) sdkFind(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkFind")
	defer func() {
		exit(err)
	}()
	// If any required fields in the input shape are missing, AWS resource is
	// not created yet. Return NotFound here to indicate to callers that the
	// resource isn't yet created.
	if rm.requiredFieldsMissingFromReadOneInput(r) {
		return nil, ackerr.NotFound
	}

	input, err := rm.newDescribeRequestPayload(r)
	if err != nil {
		return nil, err
	}
	input.Include = []svcsdktypes.TaskDefinitionField{
		svcsdktypes.TaskDefinitionFieldTags,
	}

	var resp *svcsdk.DescribeTaskDefinitionOutput
	resp, err = rm.sdkapi.DescribeTaskDefinition(ctx, input)
	rm.metrics.RecordAPICall("READ_ONE", "DescribeTaskDefinition", err)
	if err != nil {
		var awsErr smithy.APIError
		if errors.As(err, &awsErr) && awsErr.ErrorCode() == "ClientException" {
			return nil, ackerr.NotFound
		}
		return nil, err
	}

	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	if resp.TaskDefinition.Compatibilities != nil {
		f0 := []*string{}
		for _, f0iter := range resp.TaskDefinition.Compatibilities {
			var f0elem *string
			f0elem = aws.String(string(f0iter))
			f0 = append(f0, f0elem)
		}
		ko.Status.Compatibilities = f0
	} else {
		ko.Status.Compatibilities = nil
	}
	if resp.TaskDefinition.ContainerDefinitions != nil {
		f1 := []*svcapitypes.ContainerDefinition{}
		for _, f1iter := range resp.TaskDefinition.ContainerDefinitions {
			f1elem := &svcapitypes.ContainerDefinition{}
			if f1iter.Command != nil {
				f1elem.Command = aws.StringSlice(f1iter.Command)
			}
			cpuCopy := int64(f1iter.Cpu)
			f1elem.CPU = &cpuCopy
			if f1iter.CredentialSpecs != nil {
				f1elem.CredentialSpecs = aws.StringSlice(f1iter.CredentialSpecs)
			}
			if f1iter.DependsOn != nil {
				f1elemf3 := []*svcapitypes.ContainerDependency{}
				for _, f1elemf3iter := range f1iter.DependsOn {
					f1elemf3elem := &svcapitypes.ContainerDependency{}
					if f1elemf3iter.Condition != "" {
						f1elemf3elem.Condition = aws.String(string(f1elemf3iter.Condition))
					}
					if f1elemf3iter.ContainerName != nil {
						f1elemf3elem.ContainerName = f1elemf3iter.ContainerName
					}
					f1elemf3 = append(f1elemf3, f1elemf3elem)
				}
				f1elem.DependsOn = f1elemf3
			}
			if f1iter.DisableNetworking != nil {
				f1elem.DisableNetworking = f1iter.DisableNetworking
			}
			if f1iter.DnsSearchDomains != nil {
				f1elem.DNSSearchDomains = aws.StringSlice(f1iter.DnsSearchDomains)
			}
			if f1iter.DnsServers != nil {
				f1elem.DNSServers = aws.StringSlice(f1iter.DnsServers)
			}
			if f1iter.DockerLabels != nil {
				f1elem.DockerLabels = aws.StringMap(f1iter.DockerLabels)
			}
			if f1iter.DockerSecurityOptions != nil {
				f1elem.DockerSecurityOptions = aws.StringSlice(f1iter.DockerSecurityOptions)
			}
			if f1iter.EntryPoint != nil {
				f1elem.EntryPoint = aws.StringSlice(f1iter.EntryPoint)
			}
			if f1iter.Environment != nil {
				f1elemf10 := []*svcapitypes.KeyValuePair{}
				for _, f1elemf10iter := range f1iter.Environment {
					f1elemf10elem := &svcapitypes.KeyValuePair{}
					if f1elemf10iter.Name != nil {
						f1elemf10elem.Name = f1elemf10iter.Name
					}
					if f1elemf10iter.Value != nil {
						f1elemf10elem.Value = f1elemf10iter.Value
					}
					f1elemf10 = append(f1elemf10, f1elemf10elem)
				}
				f1elem.Environment = f1elemf10
			}
			if f1iter.EnvironmentFiles != nil {
				f1elemf11 := []*svcapitypes.EnvironmentFile{}
				for _, f1elemf11iter := range f1iter.EnvironmentFiles {
					f1elemf11elem := &svcapitypes.EnvironmentFile{}
					if f1elemf11iter.Type != "" {
						f1elemf11elem.Type = aws.String(string(f1elemf11iter.Type))
					}
					if f1elemf11iter.Value != nil {
						f1elemf11elem.Value = f1elemf11iter.Value
					}
					f1elemf11 = append(f1elemf11, f1elemf11elem)
				}
				f1elem.EnvironmentFiles = f1elemf11
			}
			if f1iter.Essential != nil {
				f1elem.Essential = f1iter.Essential
			}
			if f1iter.ExtraHosts != nil {
				f1elemf13 := []*svcapitypes.HostEntry{}
				for _, f1elemf13iter := range f1iter.ExtraHosts {
					f1elemf13elem := &svcapitypes.HostEntry{}
					if f1elemf13iter.Hostname != nil {
						f1elemf13elem.Hostname = f1elemf13iter.Hostname
					}
					if f1elemf13iter.IpAddress != nil {
						f1elemf13elem.IPAddress = f1elemf13iter.IpAddress
					}
					f1elemf13 = append(f1elemf13, f1elemf13elem)
				}
				f1elem.ExtraHosts = f1elemf13
			}
			if f1iter.FirelensConfiguration != nil {
				f1elemf14 := &svcapitypes.FirelensConfiguration{}
				if f1iter.FirelensConfiguration.Options != nil {
					f1elemf14.Options = aws.StringMap(f1iter.FirelensConfiguration.Options)
				}
				if f1iter.FirelensConfiguration.Type != "" {
					f1elemf14.Type = aws.String(string(f1iter.FirelensConfiguration.Type))
				}
				f1elem.FirelensConfiguration = f1elemf14
			}
			if f1iter.HealthCheck != nil {
				f1elemf15 := &svcapitypes.HealthCheck{}
				if f1iter.HealthCheck.Command != nil {
					f1elemf15.Command = aws.StringSlice(f1iter.HealthCheck.Command)
				}
				if f1iter.HealthCheck.Interval != nil {
					intervalCopy := int64(*f1iter.HealthCheck.Interval)
					f1elemf15.Interval = &intervalCopy
				}
				if f1iter.HealthCheck.Retries != nil {
					retriesCopy := int64(*f1iter.HealthCheck.Retries)
					f1elemf15.Retries = &retriesCopy
				}
				if f1iter.HealthCheck.StartPeriod != nil {
					startPeriodCopy := int64(*f1iter.HealthCheck.StartPeriod)
					f1elemf15.StartPeriod = &startPeriodCopy
				}
				if f1iter.HealthCheck.Timeout != nil {
					timeoutCopy := int64(*f1iter.HealthCheck.Timeout)
					f1elemf15.Timeout = &timeoutCopy
				}
				f1elem.HealthCheck = f1elemf15
			}
			if f1iter.Hostname != nil {
				f1elem.Hostname = f1iter.Hostname
			}
			if f1iter.Image != nil {
				f1elem.Image = f1iter.Image
			}
			if f1iter.Interactive != nil {
				f1elem.Interactive = f1iter.Interactive
			}
			if f1iter.Links != nil {
				f1elem.Links = aws.StringSlice(f1iter.Links)
			}
			if f1iter.LinuxParameters != nil {
				f1elemf20 := &svcapitypes.LinuxParameters{}
				if f1iter.LinuxParameters.Capabilities != nil {
					f1elemf20f0 := &svcapitypes.KernelCapabilities{}
					if f1iter.LinuxParameters.Capabilities.Add != nil {
						f1elemf20f0.Add = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Add)
					}
					if f1iter.LinuxParameters.Capabilities.Drop != nil {
						f1elemf20f0.Drop = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Drop)
					}
					f1elemf20.Capabilities = f1elemf20f0
				}
				if f1iter.LinuxParameters.Devices != nil {
					f1elemf20f1 := []*svcapitypes.Device{}
					for _, f1elemf20f1iter := range f1iter.LinuxParameters.Devices {
						f1elemf20f1elem := &svcapitypes.Device{}
						if f1elemf20f1iter.ContainerPath != nil {
							f1elemf20f1elem.ContainerPath = f1elemf20f1iter.ContainerPath
						}
						if f1elemf20f1iter.HostPath != nil {
							f1elemf20f1elem.HostPath = f1elemf20f1iter.HostPath
						}
						if f1elemf20f1iter.Permissions != nil {
							f1elemf20f1elemf2 := []*string{}
							for _, f1elemf20f1elemf2iter := range f1elemf20f1iter.Permissions {
								var f1elemf20f1elemf2elem *string
								f1elemf20f1elemf2elem = aws.String(string(f1elemf20f1elemf2iter))
								f1elemf20f1elemf2 = append(f1elemf20f1elemf2, f1elemf20f1elemf2elem)
							}
							f1elemf20f1elem.Permissions = f1elemf20f1elemf2
						}
						f1elemf20f1 = append(f1elemf20f1, f1elemf20f1elem)
					}
					f1elemf20.Devices = f1elemf20f1
				}
				if f1iter.LinuxParameters.InitProcessEnabled != nil {
					f1elemf20.InitProcessEnabled = f1iter.LinuxParameters.InitProcessEnabled
				}
				if f1iter.LinuxParameters.MaxSwap != nil {
					maxSwapCopy := int64(*f1iter.LinuxParameters.MaxSwap)
					f1elemf20.MaxSwap = &maxSwapCopy
				}
				if f1iter.LinuxParameters.SharedMemorySize != nil {
					sharedMemorySizeCopy := int64(*f1iter.LinuxParameters.SharedMemorySize)
					f1elemf20.SharedMemorySize = &sharedMemorySizeCopy
				}
				if f1iter.LinuxParameters.Swappiness != nil {
					swappinessCopy := int64(*f1iter.LinuxParameters.Swappiness)
					f1elemf20.Swappiness = &swappinessCopy
				}
				if f1iter.LinuxParameters.Tmpfs != nil {
					f1elemf20f6 := []*svcapitypes.Tmpfs{}
					for _, f1elemf20f6iter := range f1iter.LinuxParameters.Tmpfs {
						f1elemf20f6elem := &svcapitypes.Tmpfs{}
						if f1elemf20f6iter.ContainerPath != nil {
							f1elemf20f6elem.ContainerPath = f1elemf20f6iter.ContainerPath
						}
						if f1elemf20f6iter.MountOptions != nil {
							f1elemf20f6elem.MountOptions = aws.StringSlice(f1elemf20f6iter.MountOptions)
						}
						sizeCopy := int64(f1elemf20f6iter.Size)
						f1elemf20f6elem.Size = &sizeCopy
						f1elemf20f6 = append(f1elemf20f6, f1elemf20f6elem)
					}
					f1elemf20.Tmpfs = f1elemf20f6
				}
				f1elem.LinuxParameters = f1elemf20
			}
			if f1iter.LogConfiguration != nil {
				f1elemf21 := &svcapitypes.LogConfiguration{}
				if f1iter.LogConfiguration.LogDriver != "" {
					f1elemf21.LogDriver = aws.String(string(f1iter.LogConfiguration.LogDriver))
				}
				if f1iter.LogConfiguration.Options != nil {
					f1elemf21.Options = aws.StringMap(f1iter.LogConfiguration.Options)
				}
				if f1iter.LogConfiguration.SecretOptions != nil {
					f1elemf21f2 := []*svcapitypes.Secret{}
					for _, f1elemf21f2iter := range f1iter.LogConfiguration.SecretOptions {
						f1elemf21f2elem := &svcapitypes.Secret{}
						if f1elemf21f2iter.Name != nil {
							f1elemf21f2elem.Name = f1elemf21f2iter.Name
						}
						if f1elemf21f2iter.ValueFrom != nil {
							f1elemf21f2elem.ValueFrom = f1elemf21f2iter.ValueFrom
						}
						f1elemf21f2 = append(f1elemf21f2, f1elemf21f2elem)
					}
					f1elemf21.SecretOptions = f1elemf21f2
				}
				f1elem.LogConfiguration = f1elemf21
			}
			if f1iter.Memory != nil {
				memoryCopy := int64(*f1iter.Memory)
				f1elem.Memory = &memoryCopy
			}
			if f1iter.MemoryReservation != nil {
				memoryReservationCopy := int64(*f1iter.MemoryReservation)
				f1elem.MemoryReservation = &memoryReservationCopy
			}
			if f1iter.MountPoints != nil {
				f1elemf24 := []*svcapitypes.MountPoint{}
				for _, f1elemf24iter := range f1iter.MountPoints {
					f1elemf24elem := &svcapitypes.MountPoint{}
					if f1elemf24iter.ContainerPath != nil {
						f1elemf24elem.ContainerPath = f1elemf24iter.ContainerPath
					}
					if f1elemf24iter.ReadOnly != nil {
						f1elemf24elem.ReadOnly = f1elemf24iter.ReadOnly
					}
					if f1elemf24iter.SourceVolume != nil {
						f1elemf24elem.SourceVolume = f1elemf24iter.SourceVolume
					}
					f1elemf24 = append(f1elemf24, f1elemf24elem)
				}
				f1elem.MountPoints = f1elemf24
			}
			if f1iter.Name != nil {
				f1elem.Name = f1iter.Name
			}
			if f1iter.PortMappings != nil {
				f1elemf26 := []*svcapitypes.PortMapping{}
				for _, f1elemf26iter := range f1iter.PortMappings {
					f1elemf26elem := &svcapitypes.PortMapping{}
					if f1elemf26iter.AppProtocol != "" {
						f1elemf26elem.AppProtocol = aws.String(string(f1elemf26iter.AppProtocol))
					}
					if f1elemf26iter.ContainerPort != nil {
						containerPortCopy := int64(*f1elemf26iter.ContainerPort)
						f1elemf26elem.ContainerPort = &containerPortCopy
					}
					if f1elemf26iter.ContainerPortRange != nil {
						f1elemf26elem.ContainerPortRange = f1elemf26iter.ContainerPortRange
					}
					if f1elemf26iter.HostPort != nil {
						hostPortCopy := int64(*f1elemf26iter.HostPort)
						f1elemf26elem.HostPort = &hostPortCopy
					}
					if f1elemf26iter.Name != nil {
						f1elemf26elem.Name = f1elemf26iter.Name
					}
					if f1elemf26iter.Protocol != "" {
						f1elemf26elem.Protocol = aws.String(string(f1elemf26iter.Protocol))
					}
					f1elemf26 = append(f1elemf26, f1elemf26elem)
				}
				f1elem.PortMappings = f1elemf26
			}
			if f1iter.Privileged != nil {
				f1elem.Privileged = f1iter.Privileged
			}
			if f1iter.PseudoTerminal != nil {
				f1elem.PseudoTerminal = f1iter.PseudoTerminal
			}
			if f1iter.ReadonlyRootFilesystem != nil {
				f1elem.ReadonlyRootFilesystem = f1iter.ReadonlyRootFilesystem
			}
			if f1iter.RepositoryCredentials != nil {
				f1elemf30 := &svcapitypes.RepositoryCredentials{}
				if f1iter.RepositoryCredentials.CredentialsParameter != nil {
					f1elemf30.CredentialsParameter = f1iter.RepositoryCredentials.CredentialsParameter
				}
				f1elem.RepositoryCredentials = f1elemf30
			}
			if f1iter.ResourceRequirements != nil {
				f1elemf31 := []*svcapitypes.ResourceRequirement{}
				for _, f1elemf31iter := range f1iter.ResourceRequirements {
					f1elemf31elem := &svcapitypes.ResourceRequirement{}
					if f1elemf31iter.Type != "" {
						f1elemf31elem.Type = aws.String(string(f1elemf31iter.Type))
					}
					if f1elemf31iter.Value != nil {
						f1elemf31elem.Value = f1elemf31iter.Value
					}
					f1elemf31 = append(f1elemf31, f1elemf31elem)
				}
				f1elem.ResourceRequirements = f1elemf31
			}
			if f1iter.Secrets != nil {
				f1elemf32 := []*svcapitypes.Secret{}
				for _, f1elemf32iter := range f1iter.Secrets {
					f1elemf32elem := &svcapitypes.Secret{}
					if f1elemf32iter.Name != nil {
						f1elemf32elem.Name = f1elemf32iter.Name
					}
					if f1elemf32iter.ValueFrom != nil {
						f1elemf32elem.ValueFrom = f1elemf32iter.ValueFrom
					}
					f1elemf32 = append(f1elemf32, f1elemf32elem)
				}
				f1elem.Secrets = f1elemf32
			}
			if f1iter.StartTimeout != nil {
				startTimeoutCopy := int64(*f1iter.StartTimeout)
				f1elem.StartTimeout = &startTimeoutCopy
			}
			if f1iter.StopTimeout != nil {
				stopTimeoutCopy := int64(*f1iter.StopTimeout)
				f1elem.StopTimeout = &stopTimeoutCopy
			}
			if f1iter.SystemControls != nil {
				f1elemf35 := []*svcapitypes.SystemControl{}
				for _, f1elemf35iter := range f1iter.SystemControls {
					f1elemf35elem := &svcapitypes.SystemControl{}
					if f1elemf35iter.Namespace != nil {
						f1elemf35elem.Namespace = f1elemf35iter.Namespace
					}
					if f1elemf35iter.Value != nil {
						f1elemf35elem.Value = f1elemf35iter.Value
					}
					f1elemf35 = append(f1elemf35, f1elemf35elem)
				}
				f1elem.SystemControls = f1elemf35
			}
			if f1iter.Ulimits != nil {
				f1elemf36 := []*svcapitypes.Ulimit{}
				for _, f1elemf36iter := range f1iter.Ulimits {
					f1elemf36elem := &svcapitypes.Ulimit{}
					hardLimitCopy := int64(f1elemf36iter.HardLimit)
					f1elemf36elem.HardLimit = &hardLimitCopy
					if f1elemf36iter.Name != "" {
						f1elemf36elem.Name = aws.String(string(f1elemf36iter.Name))
					}
					softLimitCopy := int64(f1elemf36iter.SoftLimit)
					f1elemf36elem.SoftLimit = &softLimitCopy
					f1elemf36 = append(f1elemf36, f1elemf36elem)
				}
				f1elem.Ulimits = f1elemf36
			}
			if f1iter.User != nil {
				f1elem.User = f1iter.User
			}
			if f1iter.VolumesFrom != nil {
				f1elemf38 := []*svcapitypes.VolumeFrom{}
				for _, f1elemf38iter := range f1iter.VolumesFrom {
					f1elemf38elem := &svcapitypes.VolumeFrom{}
					if f1elemf38iter.ReadOnly != nil {
						f1elemf38elem.ReadOnly = f1elemf38iter.ReadOnly
					}
					if f1elemf38iter.SourceContainer != nil {
						f1elemf38elem.SourceContainer = f1elemf38iter.SourceContainer
					}
					f1elemf38 = append(f1elemf38, f1elemf38elem)
				}
				f1elem.VolumesFrom = f1elemf38
			}
			if f1iter.WorkingDirectory != nil {
				f1elem.WorkingDirectory = f1iter.WorkingDirectory
			}
			f1 = append(f1, f1elem)
		}
		ko.Spec.ContainerDefinitions = f1
	} else {
		ko.Spec.ContainerDefinitions = nil
	}
	if resp.TaskDefinition.Cpu != nil {
		ko.Spec.CPU = resp.TaskDefinition.Cpu
	} else {
		ko.Spec.CPU = nil
	}
	if resp.TaskDefinition.DeregisteredAt != nil {
		ko.Status.DeregisteredAt = &metav1.Time{*resp.TaskDefinition.DeregisteredAt}
	} else {
		ko.Status.DeregisteredAt = nil
	}
	if resp.TaskDefinition.EphemeralStorage != nil {
		f4 := &svcapitypes.EphemeralStorage{}
		sizeInGiBCopy := int64(resp.TaskDefinition.EphemeralStorage.SizeInGiB)
		f4.SizeInGiB = &sizeInGiBCopy
		ko.Spec.EphemeralStorage = f4
	} else {
		ko.Spec.EphemeralStorage = nil
	}
	if resp.TaskDefinition.ExecutionRoleArn != nil {
		ko.Spec.ExecutionRoleARN = resp.TaskDefinition.ExecutionRoleArn
	} else {
		ko.Spec.ExecutionRoleARN = nil
	}
	if resp.TaskDefinition.Family != nil {
		ko.Spec.Family = resp.TaskDefinition.Family
	} else {
		ko.Spec.Family = nil
	}
	if resp.TaskDefinition.InferenceAccelerators != nil {
		f7 := []*svcapitypes.InferenceAccelerator{}
		for _, f7iter := range resp.TaskDefinition.InferenceAccelerators {
			f7elem := &svcapitypes.InferenceAccelerator{}
			if f7iter.DeviceName != nil {
				f7elem.DeviceName = f7iter.DeviceName
			}
			if f7iter.DeviceType != nil {
				f7elem.DeviceType = f7iter.DeviceType
			}
			f7 = append(f7, f7elem)
		}
		ko.Spec.InferenceAccelerators = f7
	} else {
		ko.Spec.InferenceAccelerators = nil
	}
	if resp.TaskDefinition.IpcMode != "" {
		ko.Spec.IPCMode = aws.String(string(resp.TaskDefinition.IpcMode))
	} else {
		ko.Spec.IPCMode = nil
	}
	if resp.TaskDefinition.Memory != nil {
		ko.Spec.Memory = resp.TaskDefinition.Memory
	} else {
		ko.Spec.Memory = nil
	}
	if resp.TaskDefinition.NetworkMode != "" {
		ko.Spec.NetworkMode = aws.String(string(resp.TaskDefinition.NetworkMode))
	} else {
		ko.Spec.NetworkMode = nil
	}
	if resp.TaskDefinition.PidMode != "" {
		ko.Spec.PIDMode = aws.String(string(resp.TaskDefinition.PidMode))
	} else {
		ko.Spec.PIDMode = nil
	}
	if resp.TaskDefinition.PlacementConstraints != nil {
		f12 := []*svcapitypes.TaskDefinitionPlacementConstraint{}
		for _, f12iter := range resp.TaskDefinition.PlacementConstraints {
			f12elem := &svcapitypes.TaskDefinitionPlacementConstraint{}
			if f12iter.Expression != nil {
				f12elem.Expression = f12iter.Expression
			}
			if f12iter.Type != "" {
				f12elem.Type = aws.String(string(f12iter.Type))
			}
			f12 = append(f12, f12elem)
		}
		ko.Spec.PlacementConstraints = f12
	} else {
		ko.Spec.PlacementConstraints = nil
	}
	if resp.TaskDefinition.ProxyConfiguration != nil {
		f13 := &svcapitypes.ProxyConfiguration{}
		if resp.TaskDefinition.ProxyConfiguration.ContainerName != nil {
			f13.ContainerName = resp.TaskDefinition.ProxyConfiguration.ContainerName
		}
		if resp.TaskDefinition.ProxyConfiguration.Properties != nil {
			f13f1 := []*svcapitypes.KeyValuePair{}
			for _, f13f1iter := range resp.TaskDefinition.ProxyConfiguration.Properties {
				f13f1elem := &svcapitypes.KeyValuePair{}
				if f13f1iter.Name != nil {
					f13f1elem.Name = f13f1iter.Name
				}
				if f13f1iter.Value != nil {
					f13f1elem.Value = f13f1iter.Value
				}
				f13f1 = append(f13f1, f13f1elem)
			}
			f13.Properties = f13f1
		}
		if resp.TaskDefinition.ProxyConfiguration.Type != "" {
			f13.Type = aws.String(string(resp.TaskDefinition.ProxyConfiguration.Type))
		}
		ko.Spec.ProxyConfiguration = f13
	} else {
		ko.Spec.ProxyConfiguration = nil
	}
	if resp.TaskDefinition.RegisteredAt != nil {
		ko.Status.RegisteredAt = &metav1.Time{*resp.TaskDefinition.RegisteredAt}
	} else {
		ko.Status.RegisteredAt = nil
	}
	if resp.TaskDefinition.RegisteredBy != nil {
		ko.Status.RegisteredBy = resp.TaskDefinition.RegisteredBy
	} else {
		ko.Status.RegisteredBy = nil
	}
	if resp.TaskDefinition.RequiresAttributes != nil {
		f16 := []*svcapitypes.Attribute{}
		for _, f16iter := range resp.TaskDefinition.RequiresAttributes {
			f16elem := &svcapitypes.Attribute{}
			if f16iter.Name != nil {
				f16elem.Name = f16iter.Name
			}
			if f16iter.TargetId != nil {
				f16elem.TargetID = f16iter.TargetId
			}
			if f16iter.TargetType != "" {
				f16elem.TargetType = aws.String(string(f16iter.TargetType))
			}
			if f16iter.Value != nil {
				f16elem.Value = f16iter.Value
			}
			f16 = append(f16, f16elem)
		}
		ko.Status.RequiresAttributes = f16
	} else {
		ko.Status.RequiresAttributes = nil
	}
	if resp.TaskDefinition.RequiresCompatibilities != nil {
		f17 := []*string{}
		for _, f17iter := range resp.TaskDefinition.RequiresCompatibilities {
			var f17elem *string
			f17elem = aws.String(string(f17iter))
			f17 = append(f17, f17elem)
		}
		ko.Spec.RequiresCompatibilities = f17
	} else {
		ko.Spec.RequiresCompatibilities = nil
	}
	revisionCopy := int64(resp.TaskDefinition.Revision)
	ko.Status.Revision = &revisionCopy
	if resp.TaskDefinition.RuntimePlatform != nil {
		f19 := &svcapitypes.RuntimePlatform{}
		if resp.TaskDefinition.RuntimePlatform.CpuArchitecture != "" {
			f19.CPUArchitecture = aws.String(string(resp.TaskDefinition.RuntimePlatform.CpuArchitecture))
		}
		if resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily != "" {
			f19.OperatingSystemFamily = aws.String(string(resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily))
		}
		ko.Spec.RuntimePlatform = f19
	} else {
		ko.Spec.RuntimePlatform = nil
	}
	if resp.TaskDefinition.Status != "" {
		ko.Status.Status = aws.String(string(resp.TaskDefinition.Status))
	} else {
		ko.Status.Status = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TaskDefinition.TaskDefinitionArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TaskDefinition.TaskDefinitionArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.TaskDefinition.TaskRoleArn != nil {
		ko.Spec.TaskRoleARN = resp.TaskDefinition.TaskRoleArn
	} else {
		ko.Spec.TaskRoleARN = nil
	}
	if resp.TaskDefinition.Volumes != nil {
		f23 := []*svcapitypes.Volume{}
		for _, f23iter := range resp.TaskDefinition.Volumes {
			f23elem := &svcapitypes.Volume{}
			if f23iter.ConfiguredAtLaunch != nil {
				f23elem.ConfiguredAtLaunch = f23iter.ConfiguredAtLaunch
			}
			if f23iter.DockerVolumeConfiguration != nil {
				f23elemf1 := &svcapitypes.DockerVolumeConfiguration{}
				if f23iter.DockerVolumeConfiguration.Autoprovision != nil {
					f23elemf1.Autoprovision = f23iter.DockerVolumeConfiguration.Autoprovision
				}
				if f23iter.DockerVolumeConfiguration.Driver != nil {
					f23elemf1.Driver = f23iter.DockerVolumeConfiguration.Driver
				}
				if f23iter.DockerVolumeConfiguration.DriverOpts != nil {
					f23elemf1.DriverOpts = aws.StringMap(f23iter.DockerVolumeConfiguration.DriverOpts)
				}
				if f23iter.DockerVolumeConfiguration.Labels != nil {
					f23elemf1.Labels = aws.StringMap(f23iter.DockerVolumeConfiguration.Labels)
				}
				if f23iter.DockerVolumeConfiguration.Scope != "" {
					f23elemf1.Scope = aws.String(string(f23iter.DockerVolumeConfiguration.Scope))
				}
				f23elem.DockerVolumeConfiguration = f23elemf1
			}
			if f23iter.EfsVolumeConfiguration != nil {
				f23elemf2 := &svcapitypes.EFSVolumeConfiguration{}
				if f23iter.EfsVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf2f0 := &svcapitypes.EFSAuthorizationConfig{}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId != nil {
						f23elemf2f0.AccessPointID = f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId
					}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam != "" {
						f23elemf2f0.IAM = aws.String(string(f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam))
					}
					f23elemf2.AuthorizationConfig = f23elemf2f0
				}
				if f23iter.EfsVolumeConfiguration.FileSystemId != nil {
					f23elemf2.FileSystemID = f23iter.EfsVolumeConfiguration.FileSystemId
				}
				if f23iter.EfsVolumeConfiguration.RootDirectory != nil {
					f23elemf2.RootDirectory = f23iter.EfsVolumeConfiguration.RootDirectory
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryption != "" {
					f23elemf2.TransitEncryption = aws.String(string(f23iter.EfsVolumeConfiguration.TransitEncryption))
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryptionPort != nil {
					transitEncryptionPortCopy := int64(*f23iter.EfsVolumeConfiguration.TransitEncryptionPort)
					f23elemf2.TransitEncryptionPort = &transitEncryptionPortCopy
				}
				f23elem.EFSVolumeConfiguration = f23elemf2
			}
			if f23iter.FsxWindowsFileServerVolumeConfiguration != nil {
				f23elemf3 := &svcapitypes.FSxWindowsFileServerVolumeConfiguration{}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf3f0 := &svcapitypes.FSxWindowsFileServerAuthorizationConfig{}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
						f23elemf3f0.CredentialsParameter = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter
					}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
						f23elemf3f0.Domain = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain
					}
					f23elemf3.AuthorizationConfig = f23elemf3f0
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId != nil {
					f23elemf3.FileSystemID = f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
					f23elemf3.RootDirectory = f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory
				}
				f23elem.FsxWindowsFileServerVolumeConfiguration = f23elemf3
			}
			if f23iter.Host != nil {
				f23elemf4 := &svcapitypes.HostVolumeProperties{}
				if f23iter.Host.SourcePath != nil {
					f23elemf4.SourcePath = f23iter.Host.SourcePath
				}
				f23elem.Host = f23elemf4
			}
			if f23iter.Name != nil {
				f23elem.Name = f23iter.Name
			}
			f23 = append(f23, f23elem)
		}
		ko.Spec.Volumes = f23
	} else {
		ko.Spec.Volumes = nil
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// requiredFieldsMissingFromReadOneInput returns true if there are any fields
// for the ReadOne Input shape that are required but not present in the
// resource's Spec or Status
func (rm *resourceManager) requiredFieldsMissingFromReadOneInput(
	r *resource,
) bool {
	return r.ko.Spec.Family == nil

}

// newDescribeRequestPayload returns SDK-specific struct for the HTTP request
// payload of the Describe API call for the resource
func (rm *resourceManager) newDescribeRequestPayload(
	r *resource,
) (*svcsdk.DescribeTaskDefinitionInput, error) {
	res := &svcsdk.DescribeTaskDefinitionInput{}

	if r.ko.Spec.Family != nil {
		res.TaskDefinition = r.ko.Spec.Family
	}

	return res, nil
}

// sdkCreate creates the supplied resource in the backend AWS service API and
// returns a copy of the resource with resource fields (in both Spec and
// Status) filled in with values from the CREATE API operation's Output shape.
func (rm *resourceManager) sdkCreate(
	ctx context.Context,
	desired *resource,
) (created *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkCreate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newCreateRequestPayload(ctx, desired)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.RegisterTaskDefinitionOutput
	_ = resp
	resp, err = rm.sdkapi.RegisterTaskDefinition(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "RegisterTaskDefinition", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	if resp.TaskDefinition.Compatibilities != nil {
		f0 := []*string{}
		for _, f0iter := range resp.TaskDefinition.Compatibilities {
			var f0elem *string
			f0elem = aws.String(string(f0iter))
			f0 = append(f0, f0elem)
		}
		ko.Status.Compatibilities = f0
	} else {
		ko.Status.Compatibilities = nil
	}
	if resp.TaskDefinition.ContainerDefinitions != nil {
		f1 := []*svcapitypes.ContainerDefinition{}
		for _, f1iter := range resp.TaskDefinition.ContainerDefinitions {
			f1elem := &svcapitypes.ContainerDefinition{}
			if f1iter.Command != nil {
				f1elem.Command = aws.StringSlice(f1iter.Command)
			}
			cpuCopy := int64(f1iter.Cpu)
			f1elem.CPU = &cpuCopy
			if f1iter.CredentialSpecs != nil {
				f1elem.CredentialSpecs = aws.StringSlice(f1iter.CredentialSpecs)
			}
			if f1iter.DependsOn != nil {
				f1elemf3 := []*svcapitypes.ContainerDependency{}
				for _, f1elemf3iter := range f1iter.DependsOn {
					f1elemf3elem := &svcapitypes.ContainerDependency{}
					if f1elemf3iter.Condition != "" {
						f1elemf3elem.Condition = aws.String(string(f1elemf3iter.Condition))
					}
					if f1elemf3iter.ContainerName != nil {
						f1elemf3elem.ContainerName = f1elemf3iter.ContainerName
					}
					f1elemf3 = append(f1elemf3, f1elemf3elem)
				}
				f1elem.DependsOn = f1elemf3
			}
			if f1iter.DisableNetworking != nil {
				f1elem.DisableNetworking = f1iter.DisableNetworking
			}
			if f1iter.DnsSearchDomains != nil {
				f1elem.DNSSearchDomains = aws.StringSlice(f1iter.DnsSearchDomains)
			}
			if f1iter.DnsServers != nil {
				f1elem.DNSServers = aws.StringSlice(f1iter.DnsServers)
			}
			if f1iter.DockerLabels != nil {
				f1elem.DockerLabels = aws.StringMap(f1iter.DockerLabels)
			}
			if f1iter.DockerSecurityOptions != nil {
				f1elem.DockerSecurityOptions = aws.StringSlice(f1iter.DockerSecurityOptions)
			}
			if f1iter.EntryPoint != nil {
				f1elem.EntryPoint = aws.StringSlice(f1iter.EntryPoint)
			}
			if f1iter.Environment != nil {
				f1elemf10 := []*svcapitypes.KeyValuePair{}
				for _, f1elemf10iter := range f1iter.Environment {
					f1elemf10elem := &svcapitypes.KeyValuePair{}
					if f1elemf10iter.Name != nil {
						f1elemf10elem.Name = f1elemf10iter.Name
					}
					if f1elemf10iter.Value != nil {
						f1elemf10elem.Value = f1elemf10iter.Value
					}
					f1elemf10 = append(f1elemf10, f1elemf10elem)
				}
				f1elem.Environment = f1elemf10
			}
			if f1iter.EnvironmentFiles != nil {
				f1elemf11 := []*svcapitypes.EnvironmentFile{}
				for _, f1elemf11iter := range f1iter.EnvironmentFiles {
					f1elemf11elem := &svcapitypes.EnvironmentFile{}
					if f1elemf11iter.Type != "" {
						f1elemf11elem.Type = aws.String(string(f1elemf11iter.Type))
					}
					if f1elemf11iter.Value != nil {
						f1elemf11elem.Value = f1elemf11iter.Value
					}
					f1elemf11 = append(f1elemf11, f1elemf11elem)
				}
				f1elem.EnvironmentFiles = f1elemf11
			}
			if f1iter.Essential != nil {
				f1elem.Essential = f1iter.Essential
			}
			if f1iter.ExtraHosts != nil {
				f1elemf13 := []*svcapitypes.HostEntry{}
				for _, f1elemf13iter := range f1iter.ExtraHosts {
					f1elemf13elem := &svcapitypes.HostEntry{}
					if f1elemf13iter.Hostname != nil {
						f1elemf13elem.Hostname = f1elemf13iter.Hostname
					}
					if f1elemf13iter.IpAddress != nil {
						f1elemf13elem.IPAddress = f1elemf13iter.IpAddress
					}
					f1elemf13 = append(f1elemf13, f1elemf13elem)
				}
				f1elem.ExtraHosts = f1elemf13
			}
			if f1iter.FirelensConfiguration != nil {
				f1elemf14 := &svcapitypes.FirelensConfiguration{}
				if f1iter.FirelensConfiguration.Options != nil {
					f1elemf14.Options = aws.StringMap(f1iter.FirelensConfiguration.Options)
				}
				if f1iter.FirelensConfiguration.Type != "" {
					f1elemf14.Type = aws.String(string(f1iter.FirelensConfiguration.Type))
				}
				f1elem.FirelensConfiguration = f1elemf14
			}
			if f1iter.HealthCheck != nil {
				f1elemf15 := &svcapitypes.HealthCheck{}
				if f1iter.HealthCheck.Command != nil {
					f1elemf15.Command = aws.StringSlice(f1iter.HealthCheck.Command)
				}
				if f1iter.HealthCheck.Interval != nil {
					intervalCopy := int64(*f1iter.HealthCheck.Interval)
					f1elemf15.Interval = &intervalCopy
				}
				if f1iter.HealthCheck.Retries != nil {
					retriesCopy := int64(*f1iter.HealthCheck.Retries)
					f1elemf15.Retries = &retriesCopy
				}
				if f1iter.HealthCheck.StartPeriod != nil {
					startPeriodCopy := int64(*f1iter.HealthCheck.StartPeriod)
					f1elemf15.StartPeriod = &startPeriodCopy
				}
				if f1iter.HealthCheck.Timeout != nil {
					timeoutCopy := int64(*f1iter.HealthCheck.Timeout)
					f1elemf15.Timeout = &timeoutCopy
				}
				f1elem.HealthCheck = f1elemf15
			}
			if f1iter.Hostname != nil {
				f1elem.Hostname = f1iter.Hostname
			}
			if f1iter.Image != nil {
				f1elem.Image = f1iter.Image
			}
			if f1iter.Interactive != nil {
				f1elem.Interactive = f1iter.Interactive
			}
			if f1iter.Links != nil {
				f1elem.Links = aws.StringSlice(f1iter.Links)
			}
			if f1iter.LinuxParameters != nil {
				f1elemf20 := &svcapitypes.LinuxParameters{}
				if f1iter.LinuxParameters.Capabilities != nil {
					f1elemf20f0 := &svcapitypes.KernelCapabilities{}
					if f1iter.LinuxParameters.Capabilities.Add != nil {
						f1elemf20f0.Add = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Add)
					}
					if f1iter.LinuxParameters.Capabilities.Drop != nil {
						f1elemf20f0.Drop = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Drop)
					}
					f1elemf20.Capabilities = f1elemf20f0
				}
				if f1iter.LinuxParameters.Devices != nil {
					f1elemf20f1 := []*svcapitypes.Device{}
					for _, f1elemf20f1iter := range f1iter.LinuxParameters.Devices {
						f1elemf20f1elem := &svcapitypes.Device{}
						if f1elemf20f1iter.ContainerPath != nil {
							f1elemf20f1elem.ContainerPath = f1elemf20f1iter.ContainerPath
						}
						if f1elemf20f1iter.HostPath != nil {
							f1elemf20f1elem.HostPath = f1elemf20f1iter.HostPath
						}
						if f1elemf20f1iter.Permissions != nil {
							f1elemf20f1elemf2 := []*string{}
							for _, f1elemf20f1elemf2iter := range f1elemf20f1iter.Permissions {
								var f1elemf20f1elemf2elem *string
								f1elemf20f1elemf2elem = aws.String(string(f1elemf20f1elemf2iter))
								f1elemf20f1elemf2 = append(f1elemf20f1elemf2, f1elemf20f1elemf2elem)
							}
							f1elemf20f1elem.Permissions = f1elemf20f1elemf2
						}
						f1elemf20f1 = append(f1elemf20f1, f1elemf20f1elem)
					}
					f1elemf20.Devices = f1elemf20f1
				}
				if f1iter.LinuxParameters.InitProcessEnabled != nil {
					f1elemf20.InitProcessEnabled = f1iter.LinuxParameters.InitProcessEnabled
				}
				if f1iter.LinuxParameters.MaxSwap != nil {
					maxSwapCopy := int64(*f1iter.LinuxParameters.MaxSwap)
					f1elemf20.MaxSwap = &maxSwapCopy
				}
				if f1iter.LinuxParameters.SharedMemorySize != nil {
					sharedMemorySizeCopy := int64(*f1iter.LinuxParameters.SharedMemorySize)
					f1elemf20.SharedMemorySize = &sharedMemorySizeCopy
				}
				if f1iter.LinuxParameters.Swappiness != nil {
					swappinessCopy := int64(*f1iter.LinuxParameters.Swappiness)
					f1elemf20.Swappiness = &swappinessCopy
				}
				if f1iter.LinuxParameters.Tmpfs != nil {
					f1elemf20f6 := []*svcapitypes.Tmpfs{}
					for _, f1elemf20f6iter := range f1iter.LinuxParameters.Tmpfs {
						f1elemf20f6elem := &svcapitypes.Tmpfs{}
						if f1elemf20f6iter.ContainerPath != nil {
							f1elemf20f6elem.ContainerPath = f1elemf20f6iter.ContainerPath
						}
						if f1elemf20f6iter.MountOptions != nil {
							f1elemf20f6elem.MountOptions = aws.StringSlice(f1elemf20f6iter.MountOptions)
						}
						sizeCopy := int64(f1elemf20f6iter.Size)
						f1elemf20f6elem.Size = &sizeCopy
						f1elemf20f6 = append(f1elemf20f6, f1elemf20f6elem)
					}
					f1elemf20.Tmpfs = f1elemf20f6
				}
				f1elem.LinuxParameters = f1elemf20
			}
			if f1iter.LogConfiguration != nil {
				f1elemf21 := &svcapitypes.LogConfiguration{}
				if f1iter.LogConfiguration.LogDriver != "" {
					f1elemf21.LogDriver = aws.String(string(f1iter.LogConfiguration.LogDriver))
				}
				if f1iter.LogConfiguration.Options != nil {
					f1elemf21.Options = aws.StringMap(f1iter.LogConfiguration.Options)
				}
				if f1iter.LogConfiguration.SecretOptions != nil {
					f1elemf21f2 := []*svcapitypes.Secret{}
					for _, f1elemf21f2iter := range f1iter.LogConfiguration.SecretOptions {
						f1elemf21f2elem := &svcapitypes.Secret{}
						if f1elemf21f2iter.Name != nil {
							f1elemf21f2elem.Name = f1elemf21f2iter.Name
						}
						if f1elemf21f2iter.ValueFrom != nil {
							f1elemf21f2elem.ValueFrom = f1elemf21f2iter.ValueFrom
						}
						f1elemf21f2 = append(f1elemf21f2, f1elemf21f2elem)
					}
					f1elemf21.SecretOptions = f1elemf21f2
				}
				f1elem.LogConfiguration = f1elemf21
			}
			if f1iter.Memory != nil {
				memoryCopy := int64(*f1iter.Memory)
				f1elem.Memory = &memoryCopy
			}
			if f1iter.MemoryReservation != nil {
				memoryReservationCopy := int64(*f1iter.MemoryReservation)
				f1elem.MemoryReservation = &memoryReservationCopy
			}
			if f1iter.MountPoints != nil {
				f1elemf24 := []*svcapitypes.MountPoint{}
				for _, f1elemf24iter := range f1iter.MountPoints {
					f1elemf24elem := &svcapitypes.MountPoint{}
					if f1elemf24iter.ContainerPath != nil {
						f1elemf24elem.ContainerPath = f1elemf24iter.ContainerPath
					}
					if f1elemf24iter.ReadOnly != nil {
						f1elemf24elem.ReadOnly = f1elemf24iter.ReadOnly
					}
					if f1elemf24iter.SourceVolume != nil {
						f1elemf24elem.SourceVolume = f1elemf24iter.SourceVolume
					}
					f1elemf24 = append(f1elemf24, f1elemf24elem)
				}
				f1elem.MountPoints = f1elemf24
			}
			if f1iter.Name != nil {
				f1elem.Name = f1iter.Name
			}
			if f1iter.PortMappings != nil {
				f1elemf26 := []*svcapitypes.PortMapping{}
				for _, f1elemf26iter := range f1iter.PortMappings {
					f1elemf26elem := &svcapitypes.PortMapping{}
					if f1elemf26iter.AppProtocol != "" {
						f1elemf26elem.AppProtocol = aws.String(string(f1elemf26iter.AppProtocol))
					}
					if f1elemf26iter.ContainerPort != nil {
						containerPortCopy := int64(*f1elemf26iter.ContainerPort)
						f1elemf26elem.ContainerPort = &containerPortCopy
					}
					if f1elemf26iter.ContainerPortRange != nil {
						f1elemf26elem.ContainerPortRange = f1elemf26iter.ContainerPortRange
					}
					if f1elemf26iter.HostPort != nil {
						hostPortCopy := int64(*f1elemf26iter.HostPort)
						f1elemf26elem.HostPort = &hostPortCopy
					}
					if f1elemf26iter.Name != nil {
						f1elemf26elem.Name = f1elemf26iter.Name
					}
					if f1elemf26iter.Protocol != "" {
						f1elemf26elem.Protocol = aws.String(string(f1elemf26iter.Protocol))
					}
					f1elemf26 = append(f1elemf26, f1elemf26elem)
				}
				f1elem.PortMappings = f1elemf26
			}
			if f1iter.Privileged != nil {
				f1elem.Privileged = f1iter.Privileged
			}
			if f1iter.PseudoTerminal != nil {
				f1elem.PseudoTerminal = f1iter.PseudoTerminal
			}
			if f1iter.ReadonlyRootFilesystem != nil {
				f1elem.ReadonlyRootFilesystem = f1iter.ReadonlyRootFilesystem
			}
			if f1iter.RepositoryCredentials != nil {
				f1elemf30 := &svcapitypes.RepositoryCredentials{}
				if f1iter.RepositoryCredentials.CredentialsParameter != nil {
					f1elemf30.CredentialsParameter = f1iter.RepositoryCredentials.CredentialsParameter
				}
				f1elem.RepositoryCredentials = f1elemf30
			}
			if f1iter.ResourceRequirements != nil {
				f1elemf31 := []*svcapitypes.ResourceRequirement{}
				for _, f1elemf31iter := range f1iter.ResourceRequirements {
					f1elemf31elem := &svcapitypes.ResourceRequirement{}
					if f1elemf31iter.Type != "" {
						f1elemf31elem.Type = aws.String(string(f1elemf31iter.Type))
					}
					if f1elemf31iter.Value != nil {
						f1elemf31elem.Value = f1elemf31iter.Value
					}
					f1elemf31 = append(f1elemf31, f1elemf31elem)
				}
				f1elem.ResourceRequirements = f1elemf31
			}
			if f1iter.Secrets != nil {
				f1elemf32 := []*svcapitypes.Secret{}
				for _, f1elemf32iter := range f1iter.Secrets {
					f1elemf32elem := &svcapitypes.Secret{}
					if f1elemf32iter.Name != nil {
						f1elemf32elem.Name = f1elemf32iter.Name
					}
					if f1elemf32iter.ValueFrom != nil {
						f1elemf32elem.ValueFrom = f1elemf32iter.ValueFrom
					}
					f1elemf32 = append(f1elemf32, f1elemf32elem)
				}
				f1elem.Secrets = f1elemf32
			}
			if f1iter.StartTimeout != nil {
				startTimeoutCopy := int64(*f1iter.StartTimeout)
				f1elem.StartTimeout = &startTimeoutCopy
			}
			if f1iter.StopTimeout != nil {
				stopTimeoutCopy := int64(*f1iter.StopTimeout)
				f1elem.StopTimeout = &stopTimeoutCopy
			}
			if f1iter.SystemControls != nil {
				f1elemf35 := []*svcapitypes.SystemControl{}
				for _, f1elemf35iter := range f1iter.SystemControls {
					f1elemf35elem := &svcapitypes.SystemControl{}
					if f1elemf35iter.Namespace != nil {
						f1elemf35elem.Namespace = f1elemf35iter.Namespace
					}
					if f1elemf35iter.Value != nil {
						f1elemf35elem.Value = f1elemf35iter.Value
					}
					f1elemf35 = append(f1elemf35, f1elemf35elem)
				}
				f1elem.SystemControls = f1elemf35
			}
			if f1iter.Ulimits != nil {
				f1elemf36 := []*svcapitypes.Ulimit{}
				for _, f1elemf36iter := range f1iter.Ulimits {
					f1elemf36elem := &svcapitypes.Ulimit{}
					hardLimitCopy := int64(f1elemf36iter.HardLimit)
					f1elemf36elem.HardLimit = &hardLimitCopy
					if f1elemf36iter.Name != "" {
						f1elemf36elem.Name = aws.String(string(f1elemf36iter.Name))
					}
					softLimitCopy := int64(f1elemf36iter.SoftLimit)
					f1elemf36elem.SoftLimit = &softLimitCopy
					f1elemf36 = append(f1elemf36, f1elemf36elem)
				}
				f1elem.Ulimits = f1elemf36
			}
			if f1iter.User != nil {
				f1elem.User = f1iter.User
			}
			if f1iter.VolumesFrom != nil {
				f1elemf38 := []*svcapitypes.VolumeFrom{}
				for _, f1elemf38iter := range f1iter.VolumesFrom {
					f1elemf38elem := &svcapitypes.VolumeFrom{}
					if f1elemf38iter.ReadOnly != nil {
						f1elemf38elem.ReadOnly = f1elemf38iter.ReadOnly
					}
					if f1elemf38iter.SourceContainer != nil {
						f1elemf38elem.SourceContainer = f1elemf38iter.SourceContainer
					}
					f1elemf38 = append(f1elemf38, f1elemf38elem)
				}
				f1elem.VolumesFrom = f1elemf38
			}
			if f1iter.WorkingDirectory != nil {
				f1elem.WorkingDirectory = f1iter.WorkingDirectory
			}
			f1 = append(f1, f1elem)
		}
		ko.Spec.ContainerDefinitions = f1
	} else {
		ko.Spec.ContainerDefinitions = nil
	}
	if resp.TaskDefinition.Cpu != nil {
		ko.Spec.CPU = resp.TaskDefinition.Cpu
	} else {
		ko.Spec.CPU = nil
	}
	if resp.TaskDefinition.DeregisteredAt != nil {
		ko.Status.DeregisteredAt = &metav1.Time{*resp.TaskDefinition.DeregisteredAt}
	} else {
		ko.Status.DeregisteredAt = nil
	}
	if resp.TaskDefinition.EphemeralStorage != nil {
		f4 := &svcapitypes.EphemeralStorage{}
		sizeInGiBCopy := int64(resp.TaskDefinition.EphemeralStorage.SizeInGiB)
		f4.SizeInGiB = &sizeInGiBCopy
		ko.Spec.EphemeralStorage = f4
	} else {
		ko.Spec.EphemeralStorage = nil
	}
	if resp.TaskDefinition.ExecutionRoleArn != nil {
		ko.Spec.ExecutionRoleARN = resp.TaskDefinition.ExecutionRoleArn
	} else {
		ko.Spec.ExecutionRoleARN = nil
	}
	if resp.TaskDefinition.Family != nil {
		ko.Spec.Family = resp.TaskDefinition.Family
	} else {
		ko.Spec.Family = nil
	}
	if resp.TaskDefinition.InferenceAccelerators != nil {
		f7 := []*svcapitypes.InferenceAccelerator{}
		for _, f7iter := range resp.TaskDefinition.InferenceAccelerators {
			f7elem := &svcapitypes.InferenceAccelerator{}
			if f7iter.DeviceName != nil {
				f7elem.DeviceName = f7iter.DeviceName
			}
			if f7iter.DeviceType != nil {
				f7elem.DeviceType = f7iter.DeviceType
			}
			f7 = append(f7, f7elem)
		}
		ko.Spec.InferenceAccelerators = f7
	} else {
		ko.Spec.InferenceAccelerators = nil
	}
	if resp.TaskDefinition.IpcMode != "" {
		ko.Spec.IPCMode = aws.String(string(resp.TaskDefinition.IpcMode))
	} else {
		ko.Spec.IPCMode = nil
	}
	if resp.TaskDefinition.Memory != nil {
		ko.Spec.Memory = resp.TaskDefinition.Memory
	} else {
		ko.Spec.Memory = nil
	}
	if resp.TaskDefinition.NetworkMode != "" {
		ko.Spec.NetworkMode = aws.String(string(resp.TaskDefinition.NetworkMode))
	} else {
		ko.Spec.NetworkMode = nil
	}
	if resp.TaskDefinition.PidMode != "" {
		ko.Spec.PIDMode = aws.String(string(resp.TaskDefinition.PidMode))
	} else {
		ko.Spec.PIDMode = nil
	}
	if resp.TaskDefinition.PlacementConstraints != nil {
		f12 := []*svcapitypes.TaskDefinitionPlacementConstraint{}
		for _, f12iter := range resp.TaskDefinition.PlacementConstraints {
			f12elem := &svcapitypes.TaskDefinitionPlacementConstraint{}
			if f12iter.Expression != nil {
				f12elem.Expression = f12iter.Expression
			}
			if f12iter.Type != "" {
				f12elem.Type = aws.String(string(f12iter.Type))
			}
			f12 = append(f12, f12elem)
		}
		ko.Spec.PlacementConstraints = f12
	} else {
		ko.Spec.PlacementConstraints = nil
	}
	if resp.TaskDefinition.ProxyConfiguration != nil {
		f13 := &svcapitypes.ProxyConfiguration{}
		if resp.TaskDefinition.ProxyConfiguration.ContainerName != nil {
			f13.ContainerName = resp.TaskDefinition.ProxyConfiguration.ContainerName
		}
		if resp.TaskDefinition.ProxyConfiguration.Properties != nil {
			f13f1 := []*svcapitypes.KeyValuePair{}
			for _, f13f1iter := range resp.TaskDefinition.ProxyConfiguration.Properties {
				f13f1elem := &svcapitypes.KeyValuePair{}
				if f13f1iter.Name != nil {
					f13f1elem.Name = f13f1iter.Name
				}
				if f13f1iter.Value != nil {
					f13f1elem.Value = f13f1iter.Value
				}
				f13f1 = append(f13f1, f13f1elem)
			}
			f13.Properties = f13f1
		}
		if resp.TaskDefinition.ProxyConfiguration.Type != "" {
			f13.Type = aws.String(string(resp.TaskDefinition.ProxyConfiguration.Type))
		}
		ko.Spec.ProxyConfiguration = f13
	} else {
		ko.Spec.ProxyConfiguration = nil
	}
	if resp.TaskDefinition.RegisteredAt != nil {
		ko.Status.RegisteredAt = &metav1.Time{*resp.TaskDefinition.RegisteredAt}
	} else {
		ko.Status.RegisteredAt = nil
	}
	if resp.TaskDefinition.RegisteredBy != nil {
		ko.Status.RegisteredBy = resp.TaskDefinition.RegisteredBy
	} else {
		ko.Status.RegisteredBy = nil
	}
	if resp.TaskDefinition.RequiresAttributes != nil {
		f16 := []*svcapitypes.Attribute{}
		for _, f16iter := range resp.TaskDefinition.RequiresAttributes {
			f16elem := &svcapitypes.Attribute{}
			if f16iter.Name != nil {
				f16elem.Name = f16iter.Name
			}
			if f16iter.TargetId != nil {
				f16elem.TargetID = f16iter.TargetId
			}
			if f16iter.TargetType != "" {
				f16elem.TargetType = aws.String(string(f16iter.TargetType))
			}
			if f16iter.Value != nil {
				f16elem.Value = f16iter.Value
			}
			f16 = append(f16, f16elem)
		}
		ko.Status.RequiresAttributes = f16
	} else {
		ko.Status.RequiresAttributes = nil
	}
	if resp.TaskDefinition.RequiresCompatibilities != nil {
		f17 := []*string{}
		for _, f17iter := range resp.TaskDefinition.RequiresCompatibilities {
			var f17elem *string
			f17elem = aws.String(string(f17iter))
			f17 = append(f17, f17elem)
		}
		ko.Spec.RequiresCompatibilities = f17
	} else {
		ko.Spec.RequiresCompatibilities = nil
	}
	revisionCopy := int64(resp.TaskDefinition.Revision)
	ko.Status.Revision = &revisionCopy
	if resp.TaskDefinition.RuntimePlatform != nil {
		f19 := &svcapitypes.RuntimePlatform{}
		if resp.TaskDefinition.RuntimePlatform.CpuArchitecture != "" {
			f19.CPUArchitecture = aws.String(string(resp.TaskDefinition.RuntimePlatform.CpuArchitecture))
		}
		if resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily != "" {
			f19.OperatingSystemFamily = aws.String(string(resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily))
		}
		ko.Spec.RuntimePlatform = f19
	} else {
		ko.Spec.RuntimePlatform = nil
	}
	if resp.TaskDefinition.Status != "" {
		ko.Status.Status = aws.String(string(resp.TaskDefinition.Status))
	} else {
		ko.Status.Status = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TaskDefinition.TaskDefinitionArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TaskDefinition.TaskDefinitionArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.TaskDefinition.TaskRoleArn != nil {
		ko.Spec.TaskRoleARN = resp.TaskDefinition.TaskRoleArn
	} else {
		ko.Spec.TaskRoleARN = nil
	}
	if resp.TaskDefinition.Volumes != nil {
		f23 := []*svcapitypes.Volume{}
		for _, f23iter := range resp.TaskDefinition.Volumes {
			f23elem := &svcapitypes.Volume{}
			if f23iter.ConfiguredAtLaunch != nil {
				f23elem.ConfiguredAtLaunch = f23iter.ConfiguredAtLaunch
			}
			if f23iter.DockerVolumeConfiguration != nil {
				f23elemf1 := &svcapitypes.DockerVolumeConfiguration{}
				if f23iter.DockerVolumeConfiguration.Autoprovision != nil {
					f23elemf1.Autoprovision = f23iter.DockerVolumeConfiguration.Autoprovision
				}
				if f23iter.DockerVolumeConfiguration.Driver != nil {
					f23elemf1.Driver = f23iter.DockerVolumeConfiguration.Driver
				}
				if f23iter.DockerVolumeConfiguration.DriverOpts != nil {
					f23elemf1.DriverOpts = aws.StringMap(f23iter.DockerVolumeConfiguration.DriverOpts)
				}
				if f23iter.DockerVolumeConfiguration.Labels != nil {
					f23elemf1.Labels = aws.StringMap(f23iter.DockerVolumeConfiguration.Labels)
				}
				if f23iter.DockerVolumeConfiguration.Scope != "" {
					f23elemf1.Scope = aws.String(string(f23iter.DockerVolumeConfiguration.Scope))
				}
				f23elem.DockerVolumeConfiguration = f23elemf1
			}
			if f23iter.EfsVolumeConfiguration != nil {
				f23elemf2 := &svcapitypes.EFSVolumeConfiguration{}
				if f23iter.EfsVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf2f0 := &svcapitypes.EFSAuthorizationConfig{}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId != nil {
						f23elemf2f0.AccessPointID = f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId
					}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam != "" {
						f23elemf2f0.IAM = aws.String(string(f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam))
					}
					f23elemf2.AuthorizationConfig = f23elemf2f0
				}
				if f23iter.EfsVolumeConfiguration.FileSystemId != nil {
					f23elemf2.FileSystemID = f23iter.EfsVolumeConfiguration.FileSystemId
				}
				if f23iter.EfsVolumeConfiguration.RootDirectory != nil {
					f23elemf2.RootDirectory = f23iter.EfsVolumeConfiguration.RootDirectory
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryption != "" {
					f23elemf2.TransitEncryption = aws.String(string(f23iter.EfsVolumeConfiguration.TransitEncryption))
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryptionPort != nil {
					transitEncryptionPortCopy := int64(*f23iter.EfsVolumeConfiguration.TransitEncryptionPort)
					f23elemf2.TransitEncryptionPort = &transitEncryptionPortCopy
				}
				f23elem.EFSVolumeConfiguration = f23elemf2
			}
			if f23iter.FsxWindowsFileServerVolumeConfiguration != nil {
				f23elemf3 := &svcapitypes.FSxWindowsFileServerVolumeConfiguration{}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf3f0 := &svcapitypes.FSxWindowsFileServerAuthorizationConfig{}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
						f23elemf3f0.CredentialsParameter = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter
					}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
						f23elemf3f0.Domain = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain
					}
					f23elemf3.AuthorizationConfig = f23elemf3f0
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId != nil {
					f23elemf3.FileSystemID = f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
					f23elemf3.RootDirectory = f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory
				}
				f23elem.FsxWindowsFileServerVolumeConfiguration = f23elemf3
			}
			if f23iter.Host != nil {
				f23elemf4 := &svcapitypes.HostVolumeProperties{}
				if f23iter.Host.SourcePath != nil {
					f23elemf4.SourcePath = f23iter.Host.SourcePath
				}
				f23elem.Host = f23elemf4
			}
			if f23iter.Name != nil {
				f23elem.Name = f23iter.Name
			}
			f23 = append(f23, f23elem)
		}
		ko.Spec.Volumes = f23
	} else {
		ko.Spec.Volumes = nil
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// newCreateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Create API call for the resource
func (rm *resourceManager) newCreateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.RegisterTaskDefinitionInput, error) {
	res := &svcsdk.RegisterTaskDefinitionInput{}

	if r.ko.Spec.ContainerDefinitions != nil {
		f0 := []svcsdktypes.ContainerDefinition{}
		for _, f0iter := range r.ko.Spec.ContainerDefinitions {
			f0elem := &svcsdktypes.ContainerDefinition{}
			if f0iter.Command != nil {
				f0elem.Command = aws.ToStringSlice(f0iter.Command)
			}
			if f0iter.CPU != nil {
				cpuCopy0 := *f0iter.CPU
				if cpuCopy0 > math.MaxInt32 || cpuCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field cpu is of type int32")
				}
				cpuCopy := int32(cpuCopy0)
				f0elem.Cpu = cpuCopy
			}
			if f0iter.CredentialSpecs != nil {
				f0elem.CredentialSpecs = aws.ToStringSlice(f0iter.CredentialSpecs)
			}
			if f0iter.DependsOn != nil {
				f0elemf3 := []svcsdktypes.ContainerDependency{}
				for _, f0elemf3iter := range f0iter.DependsOn {
					f0elemf3elem := &svcsdktypes.ContainerDependency{}
					if f0elemf3iter.Condition != nil {
						f0elemf3elem.Condition = svcsdktypes.ContainerCondition(*f0elemf3iter.Condition)
					}
					if f0elemf3iter.ContainerName != nil {
						f0elemf3elem.ContainerName = f0elemf3iter.ContainerName
					}
					f0elemf3 = append(f0elemf3, *f0elemf3elem)
				}
				f0elem.DependsOn = f0elemf3
			}
			if f0iter.DisableNetworking != nil {
				f0elem.DisableNetworking = f0iter.DisableNetworking
			}
			if f0iter.DNSSearchDomains != nil {
				f0elem.DnsSearchDomains = aws.ToStringSlice(f0iter.DNSSearchDomains)
			}
			if f0iter.DNSServers != nil {
				f0elem.DnsServers = aws.ToStringSlice(f0iter.DNSServers)
			}
			if f0iter.DockerLabels != nil {
				f0elem.DockerLabels = aws.ToStringMap(f0iter.DockerLabels)
			}
			if f0iter.DockerSecurityOptions != nil {
				f0elem.DockerSecurityOptions = aws.ToStringSlice(f0iter.DockerSecurityOptions)
			}
			if f0iter.EntryPoint != nil {
				f0elem.EntryPoint = aws.ToStringSlice(f0iter.EntryPoint)
			}
			if f0iter.Environment != nil {
				f0elemf10 := []svcsdktypes.KeyValuePair{}
				for _, f0elemf10iter := range f0iter.Environment {
					f0elemf10elem := &svcsdktypes.KeyValuePair{}
					if f0elemf10iter.Name != nil {
						f0elemf10elem.Name = f0elemf10iter.Name
					}
					if f0elemf10iter.Value != nil {
						f0elemf10elem.Value = f0elemf10iter.Value
					}
					f0elemf10 = append(f0elemf10, *f0elemf10elem)
				}
				f0elem.Environment = f0elemf10
			}
			if f0iter.EnvironmentFiles != nil {
				f0elemf11 := []svcsdktypes.EnvironmentFile{}
				for _, f0elemf11iter := range f0iter.EnvironmentFiles {
					f0elemf11elem := &svcsdktypes.EnvironmentFile{}
					if f0elemf11iter.Type != nil {
						f0elemf11elem.Type = svcsdktypes.EnvironmentFileType(*f0elemf11iter.Type)
					}
					if f0elemf11iter.Value != nil {
						f0elemf11elem.Value = f0elemf11iter.Value
					}
					f0elemf11 = append(f0elemf11, *f0elemf11elem)
				}
				f0elem.EnvironmentFiles = f0elemf11
			}
			if f0iter.Essential != nil {
				f0elem.Essential = f0iter.Essential
			}
			if f0iter.ExtraHosts != nil {
				f0elemf13 := []svcsdktypes.HostEntry{}
				for _, f0elemf13iter := range f0iter.ExtraHosts {
					f0elemf13elem := &svcsdktypes.HostEntry{}
					if f0elemf13iter.Hostname != nil {
						f0elemf13elem.Hostname = f0elemf13iter.Hostname
					}
					if f0elemf13iter.IPAddress != nil {
						f0elemf13elem.IpAddress = f0elemf13iter.IPAddress
					}
					f0elemf13 = append(f0elemf13, *f0elemf13elem)
				}
				f0elem.ExtraHosts = f0elemf13
			}
			if f0iter.FirelensConfiguration != nil {
				f0elemf14 := &svcsdktypes.FirelensConfiguration{}
				if f0iter.FirelensConfiguration.Options != nil {
					f0elemf14.Options = aws.ToStringMap(f0iter.FirelensConfiguration.Options)
				}
				if f0iter.FirelensConfiguration.Type != nil {
					f0elemf14.Type = svcsdktypes.FirelensConfigurationType(*f0iter.FirelensConfiguration.Type)
				}
				f0elem.FirelensConfiguration = f0elemf14
			}
			if f0iter.HealthCheck != nil {
				f0elemf15 := &svcsdktypes.HealthCheck{}
				if f0iter.HealthCheck.Command != nil {
					f0elemf15.Command = aws.ToStringSlice(f0iter.HealthCheck.Command)
				}
				if f0iter.HealthCheck.Interval != nil {
					intervalCopy0 := *f0iter.HealthCheck.Interval
					if intervalCopy0 > math.MaxInt32 || intervalCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field interval is of type int32")
					}
					intervalCopy := int32(intervalCopy0)
					f0elemf15.Interval = &intervalCopy
				}
				if f0iter.HealthCheck.Retries != nil {
					retriesCopy0 := *f0iter.HealthCheck.Retries
					if retriesCopy0 > math.MaxInt32 || retriesCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field retries is of type int32")
					}
					retriesCopy := int32(retriesCopy0)
					f0elemf15.Retries = &retriesCopy
				}
				if f0iter.HealthCheck.StartPeriod != nil {
					startPeriodCopy0 := *f0iter.HealthCheck.StartPeriod
					if startPeriodCopy0 > math.MaxInt32 || startPeriodCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field startPeriod is of type int32")
					}
					startPeriodCopy := int32(startPeriodCopy0)
					f0elemf15.StartPeriod = &startPeriodCopy
				}
				if f0iter.HealthCheck.Timeout != nil {
					timeoutCopy0 := *f0iter.HealthCheck.Timeout
					if timeoutCopy0 > math.MaxInt32 || timeoutCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field timeout is of type int32")
					}
					timeoutCopy := int32(timeoutCopy0)
					f0elemf15.Timeout = &timeoutCopy
				}
				f0elem.HealthCheck = f0elemf15
			}
			if f0iter.Hostname != nil {
				f0elem.Hostname = f0iter.Hostname
			}
			if f0iter.Image != nil {
				f0elem.Image = f0iter.Image
			}
			if f0iter.Interactive != nil {
				f0elem.Interactive = f0iter.Interactive
			}
			if f0iter.Links != nil {
				f0elem.Links = aws.ToStringSlice(f0iter.Links)
			}
			if f0iter.LinuxParameters != nil {
				f0elemf20 := &svcsdktypes.LinuxParameters{}
				if f0iter.LinuxParameters.Capabilities != nil {
					f0elemf20f0 := &svcsdktypes.KernelCapabilities{}
					if f0iter.LinuxParameters.Capabilities.Add != nil {
						f0elemf20f0.Add = aws.ToStringSlice(f0iter.LinuxParameters.Capabilities.Add)
					}
					if f0iter.LinuxParameters.Capabilities.Drop != nil {
						f0elemf20f0.Drop = aws.ToStringSlice(f0iter.LinuxParameters.Capabilities.Drop)
					}
					f0elemf20.Capabilities = f0elemf20f0
				}
				if f0iter.LinuxParameters.Devices != nil {
					f0elemf20f1 := []svcsdktypes.Device{}
					for _, f0elemf20f1iter := range f0iter.LinuxParameters.Devices {
						f0elemf20f1elem := &svcsdktypes.Device{}
						if f0elemf20f1iter.ContainerPath != nil {
							f0elemf20f1elem.ContainerPath = f0elemf20f1iter.ContainerPath
						}
						if f0elemf20f1iter.HostPath != nil {
							f0elemf20f1elem.HostPath = f0elemf20f1iter.HostPath
						}
						if f0elemf20f1iter.Permissions != nil {
							f0elemf20f1elemf2 := []svcsdktypes.DeviceCgroupPermission{}
							for _, f0elemf20f1elemf2iter := range f0elemf20f1iter.Permissions {
								var f0elemf20f1elemf2elem string
								f0elemf20f1elemf2elem = string(*f0elemf20f1elemf2iter)
								f0elemf20f1elemf2 = append(f0elemf20f1elemf2, svcsdktypes.DeviceCgroupPermission(f0elemf20f1elemf2elem))
							}
							f0elemf20f1elem.Permissions = f0elemf20f1elemf2
						}
						f0elemf20f1 = append(f0elemf20f1, *f0elemf20f1elem)
					}
					f0elemf20.Devices = f0elemf20f1
				}
				if f0iter.LinuxParameters.InitProcessEnabled != nil {
					f0elemf20.InitProcessEnabled = f0iter.LinuxParameters.InitProcessEnabled
				}
				if f0iter.LinuxParameters.MaxSwap != nil {
					maxSwapCopy0 := *f0iter.LinuxParameters.MaxSwap
					if maxSwapCopy0 > math.MaxInt32 || maxSwapCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field maxSwap is of type int32")
					}
					maxSwapCopy := int32(maxSwapCopy0)
					f0elemf20.MaxSwap = &maxSwapCopy
				}
				if f0iter.LinuxParameters.SharedMemorySize != nil {
					sharedMemorySizeCopy0 := *f0iter.LinuxParameters.SharedMemorySize
					if sharedMemorySizeCopy0 > math.MaxInt32 || sharedMemorySizeCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field sharedMemorySize is of type int32")
					}
					sharedMemorySizeCopy := int32(sharedMemorySizeCopy0)
					f0elemf20.SharedMemorySize = &sharedMemorySizeCopy
				}
				if f0iter.LinuxParameters.Swappiness != nil {
					swappinessCopy0 := *f0iter.LinuxParameters.Swappiness
					if swappinessCopy0 > math.MaxInt32 || swappinessCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field swappiness is of type int32")
					}
					swappinessCopy := int32(swappinessCopy0)
					f0elemf20.Swappiness = &swappinessCopy
				}
				if f0iter.LinuxParameters.Tmpfs != nil {
					f0elemf20f6 := []svcsdktypes.Tmpfs{}
					for _, f0elemf20f6iter := range f0iter.LinuxParameters.Tmpfs {
						f0elemf20f6elem := &svcsdktypes.Tmpfs{}
						if f0elemf20f6iter.ContainerPath != nil {
							f0elemf20f6elem.ContainerPath = f0elemf20f6iter.ContainerPath
						}
						if f0elemf20f6iter.MountOptions != nil {
							f0elemf20f6elem.MountOptions = aws.ToStringSlice(f0elemf20f6iter.MountOptions)
						}
						if f0elemf20f6iter.Size != nil {
							sizeCopy0 := *f0elemf20f6iter.Size
							if sizeCopy0 > math.MaxInt32 || sizeCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field size is of type int32")
							}
							sizeCopy := int32(sizeCopy0)
							f0elemf20f6elem.Size = sizeCopy
						}
						f0elemf20f6 = append(f0elemf20f6, *f0elemf20f6elem)
					}
					f0elemf20.Tmpfs = f0elemf20f6
				}
				f0elem.LinuxParameters = f0elemf20
			}
			if f0iter.LogConfiguration != nil {
				f0elemf21 := &svcsdktypes.LogConfiguration{}
				if f0iter.LogConfiguration.LogDriver != nil {
					f0elemf21.LogDriver = svcsdktypes.LogDriver(*f0iter.LogConfiguration.LogDriver)
				}
				if f0iter.LogConfiguration.Options != nil {
					f0elemf21.Options = aws.ToStringMap(f0iter.LogConfiguration.Options)
				}
				if f0iter.LogConfiguration.SecretOptions != nil {
					f0elemf21f2 := []svcsdktypes.Secret{}
					for _, f0elemf21f2iter := range f0iter.LogConfiguration.SecretOptions {
						f0elemf21f2elem := &svcsdktypes.Secret{}
						if f0elemf21f2iter.Name != nil {
							f0elemf21f2elem.Name = f0elemf21f2iter.Name
						}
						if f0elemf21f2iter.ValueFrom != nil {
							f0elemf21f2elem.ValueFrom = f0elemf21f2iter.ValueFrom
						}
						f0elemf21f2 = append(f0elemf21f2, *f0elemf21f2elem)
					}
					f0elemf21.SecretOptions = f0elemf21f2
				}
				f0elem.LogConfiguration = f0elemf21
			}
			if f0iter.Memory != nil {
				memoryCopy0 := *f0iter.Memory
				if memoryCopy0 > math.MaxInt32 || memoryCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field memory is of type int32")
				}
				memoryCopy := int32(memoryCopy0)
				f0elem.Memory = &memoryCopy
			}
			if f0iter.MemoryReservation != nil {
				memoryReservationCopy0 := *f0iter.MemoryReservation
				if memoryReservationCopy0 > math.MaxInt32 || memoryReservationCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field memoryReservation is of type int32")
				}
				memoryReservationCopy := int32(memoryReservationCopy0)
				f0elem.MemoryReservation = &memoryReservationCopy
			}
			if f0iter.MountPoints != nil {
				f0elemf24 := []svcsdktypes.MountPoint{}
				for _, f0elemf24iter := range f0iter.MountPoints {
					f0elemf24elem := &svcsdktypes.MountPoint{}
					if f0elemf24iter.ContainerPath != nil {
						f0elemf24elem.ContainerPath = f0elemf24iter.ContainerPath
					}
					if f0elemf24iter.ReadOnly != nil {
						f0elemf24elem.ReadOnly = f0elemf24iter.ReadOnly
					}
					if f0elemf24iter.SourceVolume != nil {
						f0elemf24elem.SourceVolume = f0elemf24iter.SourceVolume
					}
					f0elemf24 = append(f0elemf24, *f0elemf24elem)
				}
				f0elem.MountPoints = f0elemf24
			}
			if f0iter.Name != nil {
				f0elem.Name = f0iter.Name
			}
			if f0iter.PortMappings != nil {
				f0elemf26 := []svcsdktypes.PortMapping{}
				for _, f0elemf26iter := range f0iter.PortMappings {
					f0elemf26elem := &svcsdktypes.PortMapping{}
					if f0elemf26iter.AppProtocol != nil {
						f0elemf26elem.AppProtocol = svcsdktypes.ApplicationProtocol(*f0elemf26iter.AppProtocol)
					}
					if f0elemf26iter.ContainerPort != nil {
						containerPortCopy0 := *f0elemf26iter.ContainerPort
						if containerPortCopy0 > math.MaxInt32 || containerPortCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field containerPort is of type int32")
						}
						containerPortCopy := int32(containerPortCopy0)
						f0elemf26elem.ContainerPort = &containerPortCopy
					}
					if f0elemf26iter.ContainerPortRange != nil {
						f0elemf26elem.ContainerPortRange = f0elemf26iter.ContainerPortRange
					}
					if f0elemf26iter.HostPort != nil {
						hostPortCopy0 := *f0elemf26iter.HostPort
						if hostPortCopy0 > math.MaxInt32 || hostPortCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field hostPort is of type int32")
						}
						hostPortCopy := int32(hostPortCopy0)
						f0elemf26elem.HostPort = &hostPortCopy
					}
					if f0elemf26iter.Name != nil {
						f0elemf26elem.Name = f0elemf26iter.Name
					}
					if f0elemf26iter.Protocol != nil {
						f0elemf26elem.Protocol = svcsdktypes.TransportProtocol(*f0elemf26iter.Protocol)
					}
					f0elemf26 = append(f0elemf26, *f0elemf26elem)
				}
				f0elem.PortMappings = f0elemf26
			}
			if f0iter.Privileged != nil {
				f0elem.Privileged = f0iter.Privileged
			}
			if f0iter.PseudoTerminal != nil {
				f0elem.PseudoTerminal = f0iter.PseudoTerminal
			}
			if f0iter.ReadonlyRootFilesystem != nil {
				f0elem.ReadonlyRootFilesystem = f0iter.ReadonlyRootFilesystem
			}
			if f0iter.RepositoryCredentials != nil {
				f0elemf30 := &svcsdktypes.RepositoryCredentials{}
				if f0iter.RepositoryCredentials.CredentialsParameter != nil {
					f0elemf30.CredentialsParameter = f0iter.RepositoryCredentials.CredentialsParameter
				}
				f0elem.RepositoryCredentials = f0elemf30
			}
			if f0iter.ResourceRequirements != nil {
				f0elemf31 := []svcsdktypes.ResourceRequirement{}
				for _, f0elemf31iter := range f0iter.ResourceRequirements {
					f0elemf31elem := &svcsdktypes.ResourceRequirement{}
					if f0elemf31iter.Type != nil {
						f0elemf31elem.Type = svcsdktypes.ResourceType(*f0elemf31iter.Type)
					}
					if f0elemf31iter.Value != nil {
						f0elemf31elem.Value = f0elemf31iter.Value
					}
					f0elemf31 = append(f0elemf31, *f0elemf31elem)
				}
				f0elem.ResourceRequirements = f0elemf31
			}
			if f0iter.Secrets != nil {
				f0elemf32 := []svcsdktypes.Secret{}
				for _, f0elemf32iter := range f0iter.Secrets {
					f0elemf32elem := &svcsdktypes.Secret{}
					if f0elemf32iter.Name != nil {
						f0elemf32elem.Name = f0elemf32iter.Name
					}
					if f0elemf32iter.ValueFrom != nil {
						f0elemf32elem.ValueFrom = f0elemf32iter.ValueFrom
					}
					f0elemf32 = append(f0elemf32, *f0elemf32elem)
				}
				f0elem.Secrets = f0elemf32
			}
			if f0iter.StartTimeout != nil {
				startTimeoutCopy0 := *f0iter.StartTimeout
				if startTimeoutCopy0 > math.MaxInt32 || startTimeoutCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field startTimeout is of type int32")
				}
				startTimeoutCopy := int32(startTimeoutCopy0)
				f0elem.StartTimeout = &startTimeoutCopy
			}
			if f0iter.StopTimeout != nil {
				stopTimeoutCopy0 := *f0iter.StopTimeout
				if stopTimeoutCopy0 > math.MaxInt32 || stopTimeoutCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field stopTimeout is of type int32")
				}
				stopTimeoutCopy := int32(stopTimeoutCopy0)
				f0elem.StopTimeout = &stopTimeoutCopy
			}
			if f0iter.SystemControls != nil {
				f0elemf35 := []svcsdktypes.SystemControl{}
				for _, f0elemf35iter := range f0iter.SystemControls {
					f0elemf35elem := &svcsdktypes.SystemControl{}
					if f0elemf35iter.Namespace != nil {
						f0elemf35elem.Namespace = f0elemf35iter.Namespace
					}
					if f0elemf35iter.Value != nil {
						f0elemf35elem.Value = f0elemf35iter.Value
					}
					f0elemf35 = append(f0elemf35, *f0elemf35elem)
				}
				f0elem.SystemControls = f0elemf35
			}
			if f0iter.Ulimits != nil {
				f0elemf36 := []svcsdktypes.Ulimit{}
				for _, f0elemf36iter := range f0iter.Ulimits {
					f0elemf36elem := &svcsdktypes.Ulimit{}
					if f0elemf36iter.HardLimit != nil {
						hardLimitCopy0 := *f0elemf36iter.HardLimit
						if hardLimitCopy0 > math.MaxInt32 || hardLimitCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field hardLimit is of type int32")
						}
						hardLimitCopy := int32(hardLimitCopy0)
						f0elemf36elem.HardLimit = hardLimitCopy
					}
					if f0elemf36iter.Name != nil {
						f0elemf36elem.Name = svcsdktypes.UlimitName(*f0elemf36iter.Name)
					}
					if f0elemf36iter.SoftLimit != nil {
						softLimitCopy0 := *f0elemf36iter.SoftLimit
						if softLimitCopy0 > math.MaxInt32 || softLimitCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field softLimit is of type int32")
						}
						softLimitCopy := int32(softLimitCopy0)
						f0elemf36elem.SoftLimit = softLimitCopy
					}
					f0elemf36 = append(f0elemf36, *f0elemf36elem)
				}
				f0elem.Ulimits = f0elemf36
			}
			if f0iter.User != nil {
				f0elem.User = f0iter.User
			}
			if f0iter.VolumesFrom != nil {
				f0elemf38 := []svcsdktypes.VolumeFrom{}
				for _, f0elemf38iter := range f0iter.VolumesFrom {
					f0elemf38elem := &svcsdktypes.VolumeFrom{}
					if f0elemf38iter.ReadOnly != nil {
						f0elemf38elem.ReadOnly = f0elemf38iter.ReadOnly
					}
					if f0elemf38iter.SourceContainer != nil {
						f0elemf38elem.SourceContainer = f0elemf38iter.SourceContainer
					}
					f0elemf38 = append(f0elemf38, *f0elemf38elem)
				}
				f0elem.VolumesFrom = f0elemf38
			}
			if f0iter.WorkingDirectory != nil {
				f0elem.WorkingDirectory = f0iter.WorkingDirectory
			}
			f0 = append(f0, *f0elem)
		}
		res.ContainerDefinitions = f0
	}
	if r.ko.Spec.CPU != nil {
		res.Cpu = r.ko.Spec.CPU
	}
	if r.ko.Spec.EphemeralStorage != nil {
		f2 := &svcsdktypes.EphemeralStorage{}
		if r.ko.Spec.EphemeralStorage.SizeInGiB != nil {
			sizeInGiBCopy0 := *r.ko.Spec.EphemeralStorage.SizeInGiB
			if sizeInGiBCopy0 > math.MaxInt32 || sizeInGiBCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field sizeInGiB is of type int32")
			}
			sizeInGiBCopy := int32(sizeInGiBCopy0)
			f2.SizeInGiB = sizeInGiBCopy
		}
		res.EphemeralStorage = f2
	}
	if r.ko.Spec.ExecutionRoleARN != nil {
		res.ExecutionRoleArn = r.ko.Spec.ExecutionRoleARN
	}
	if r.ko.Spec.Family != nil {
		res.Family = r.ko.Spec.Family
	}
	if r.ko.Spec.InferenceAccelerators != nil {
		f5 := []svcsdktypes.InferenceAccelerator{}
		for _, f5iter := range r.ko.Spec.InferenceAccelerators {
			f5elem := &svcsdktypes.InferenceAccelerator{}
			if f5iter.DeviceName != nil {
				f5elem.DeviceName = f5iter.DeviceName
			}
			if f5iter.DeviceType != nil {
				f5elem.DeviceType = f5iter.DeviceType
			}
			f5 = append(f5, *f5elem)
		}
		res.InferenceAccelerators = f5
	}
	if r.ko.Spec.IPCMode != nil {
		res.IpcMode = svcsdktypes.IpcMode(*r.ko.Spec.IPCMode)
	}
	if r.ko.Spec.Memory != nil {
		res.Memory = r.ko.Spec.Memory
	}
	if r.ko.Spec.NetworkMode != nil {
		res.NetworkMode = svcsdktypes.NetworkMode(*r.ko.Spec.NetworkMode)
	}
	if r.ko.Spec.PIDMode != nil {
		res.PidMode = svcsdktypes.PidMode(*r.ko.Spec.PIDMode)
	}
	if r.ko.Spec.PlacementConstraints != nil {
		f10 := []svcsdktypes.TaskDefinitionPlacementConstraint{}
		for _, f10iter := range r.ko.Spec.PlacementConstraints {
			f10elem := &svcsdktypes.TaskDefinitionPlacementConstraint{}
			if f10iter.Expression != nil {
				f10elem.Expression = f10iter.Expression
			}
			if f10iter.Type != nil {
				f10elem.Type = svcsdktypes.TaskDefinitionPlacementConstraintType(*f10iter.Type)
			}
			f10 = append(f10, *f10elem)
		}
		res.PlacementConstraints = f10
	}
	if r.ko.Spec.ProxyConfiguration != nil {
		f11 := &svcsdktypes.ProxyConfiguration{}
		if r.ko.Spec.ProxyConfiguration.ContainerName != nil {
			f11.ContainerName = r.ko.Spec.ProxyConfiguration.ContainerName
		}
		if r.ko.Spec.ProxyConfiguration.Properties != nil {
			f11f1 := []svcsdktypes.KeyValuePair{}
			for _, f11f1iter := range r.ko.Spec.ProxyConfiguration.Properties {
				f11f1elem := &svcsdktypes.KeyValuePair{}
				if f11f1iter.Name != nil {
					f11f1elem.Name = f11f1iter.Name
				}
				if f11f1iter.Value != nil {
					f11f1elem.Value = f11f1iter.Value
				}
				f11f1 = append(f11f1, *f11f1elem)
			}
			f11.Properties = f11f1
		}
		if r.ko.Spec.ProxyConfiguration.Type != nil {
			f11.Type = svcsdktypes.ProxyConfigurationType(*r.ko.Spec.ProxyConfiguration.Type)
		}
		res.ProxyConfiguration = f11
	}
	if r.ko.Spec.RequiresCompatibilities != nil {
		f12 := []svcsdktypes.Compatibility{}
		for _, f12iter := range r.ko.Spec.RequiresCompatibilities {
			var f12elem string
			f12elem = string(*f12iter)
			f12 = append(f12, svcsdktypes.Compatibility(f12elem))
		}
		res.RequiresCompatibilities = f12
	}
	if r.ko.Spec.RuntimePlatform != nil {
		f13 := &svcsdktypes.RuntimePlatform{}
		if r.ko.Spec.RuntimePlatform.CPUArchitecture != nil {
			f13.CpuArchitecture = svcsdktypes.CPUArchitecture(*r.ko.Spec.RuntimePlatform.CPUArchitecture)
		}
		if r.ko.Spec.RuntimePlatform.OperatingSystemFamily != nil {
			f13.OperatingSystemFamily = svcsdktypes.OSFamily(*r.ko.Spec.RuntimePlatform.OperatingSystemFamily)
		}
		res.RuntimePlatform = f13
	}
	if r.ko.Spec.Tags != nil {
		f14 := []svcsdktypes.Tag{}
		for _, f14iter := range r.ko.Spec.Tags {
			f14elem := &svcsdktypes.Tag{}
			if f14iter.Key != nil {
				f14elem.Key = f14iter.Key
			}
			if f14iter.Value != nil {
				f14elem.Value = f14iter.Value
			}
			f14 = append(f14, *f14elem)
		}
		res.Tags = f14
	}
	if r.ko.Spec.TaskRoleARN != nil {
		res.TaskRoleArn = r.ko.Spec.TaskRoleARN
	}
	if r.ko.Spec.Volumes != nil {
		f16 := []svcsdktypes.Volume{}
		for _, f16iter := range r.ko.Spec.Volumes {
			f16elem := &svcsdktypes.Volume{}
			if f16iter.ConfiguredAtLaunch != nil {
				f16elem.ConfiguredAtLaunch = f16iter.ConfiguredAtLaunch
			}
			if f16iter.DockerVolumeConfiguration != nil {
				f16elemf1 := &svcsdktypes.DockerVolumeConfiguration{}
				if f16iter.DockerVolumeConfiguration.Autoprovision != nil {
					f16elemf1.Autoprovision = f16iter.DockerVolumeConfiguration.Autoprovision
				}
				if f16iter.DockerVolumeConfiguration.Driver != nil {
					f16elemf1.Driver = f16iter.DockerVolumeConfiguration.Driver
				}
				if f16iter.DockerVolumeConfiguration.DriverOpts != nil {
					f16elemf1.DriverOpts = aws.ToStringMap(f16iter.DockerVolumeConfiguration.DriverOpts)
				}
				if f16iter.DockerVolumeConfiguration.Labels != nil {
					f16elemf1.Labels = aws.ToStringMap(f16iter.DockerVolumeConfiguration.Labels)
				}
				if f16iter.DockerVolumeConfiguration.Scope != nil {
					f16elemf1.Scope = svcsdktypes.Scope(*f16iter.DockerVolumeConfiguration.Scope)
				}
				f16elem.DockerVolumeConfiguration = f16elemf1
			}
			if f16iter.EFSVolumeConfiguration != nil {
				f16elemf2 := &svcsdktypes.EFSVolumeConfiguration{}
				if f16iter.EFSVolumeConfiguration.AuthorizationConfig != nil {
					f16elemf2f0 := &svcsdktypes.EFSAuthorizationConfig{}
					if f16iter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID != nil {
						f16elemf2f0.AccessPointId = f16iter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID
					}
					if f16iter.EFSVolumeConfiguration.AuthorizationConfig.IAM != nil {
						f16elemf2f0.Iam = svcsdktypes.EFSAuthorizationConfigIAM(*f16iter.EFSVolumeConfiguration.AuthorizationConfig.IAM)
					}
					f16elemf2.AuthorizationConfig = f16elemf2f0
				}
				if f16iter.EFSVolumeConfiguration.FileSystemID != nil {
					f16elemf2.FileSystemId = f16iter.EFSVolumeConfiguration.FileSystemID
				}
				if f16iter.EFSVolumeConfiguration.RootDirectory != nil {
					f16elemf2.RootDirectory = f16iter.EFSVolumeConfiguration.RootDirectory
				}
				if f16iter.EFSVolumeConfiguration.TransitEncryption != nil {
					f16elemf2.TransitEncryption = svcsdktypes.EFSTransitEncryption(*f16iter.EFSVolumeConfiguration.TransitEncryption)
				}
				if f16iter.EFSVolumeConfiguration.TransitEncryptionPort != nil {
					transitEncryptionPortCopy0 := *f16iter.EFSVolumeConfiguration.TransitEncryptionPort
					if transitEncryptionPortCopy0 > math.MaxInt32 || transitEncryptionPortCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field transitEncryptionPort is of type int32")
					}
					transitEncryptionPortCopy := int32(transitEncryptionPortCopy0)
					f16elemf2.TransitEncryptionPort = &transitEncryptionPortCopy
				}
				f16elem.EfsVolumeConfiguration = f16elemf2
			}
			if f16iter.FsxWindowsFileServerVolumeConfiguration != nil {
				f16elemf3 := &svcsdktypes.FSxWindowsFileServerVolumeConfiguration{}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
					f16elemf3f0 := &svcsdktypes.FSxWindowsFileServerAuthorizationConfig{}
					if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
						f16elemf3f0.CredentialsParameter = f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter
					}
					if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
						f16elemf3f0.Domain = f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain
					}
					f16elemf3.AuthorizationConfig = f16elemf3f0
				}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.FileSystemID != nil {
					f16elemf3.FileSystemId = f16iter.FsxWindowsFileServerVolumeConfiguration.FileSystemID
				}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
					f16elemf3.RootDirectory = f16iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory
				}
				f16elem.FsxWindowsFileServerVolumeConfiguration = f16elemf3
			}
			if f16iter.Host != nil {
				f16elemf4 := &svcsdktypes.HostVolumeProperties{}
				if f16iter.Host.SourcePath != nil {
					f16elemf4.SourcePath = f16iter.Host.SourcePath
				}
				f16elem.Host = f16elemf4
			}
			if f16iter.Name != nil {
				f16elem.Name = f16iter.Name
			}
			f16 = append(f16, *f16elem)
		}
		res.Volumes = f16
	}

	return res, nil
}

// sdkUpdate patches the supplied resource in the backend AWS service API and
// returns a new resource with updated fields.
func (rm *resourceManager) sdkUpdate(
	ctx context.Context,
	desired *resource,
	latest *resource,
	delta *ackcompare.Delta,
) (updated *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkUpdate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newUpdateRequestPayload(ctx, desired, delta)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.RegisterTaskDefinitionOutput
	_ = resp
	resp, err = rm.sdkapi.RegisterTaskDefinition(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "RegisterTaskDefinition", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	if resp.TaskDefinition.Compatibilities != nil {
		f0 := []*string{}
		for _, f0iter := range resp.TaskDefinition.Compatibilities {
			var f0elem *string
			f0elem = aws.String(string(f0iter))
			f0 = append(f0, f0elem)
		}
		ko.Status.Compatibilities = f0
	} else {
		ko.Status.Compatibilities = nil
	}
	if resp.TaskDefinition.ContainerDefinitions != nil {
		f1 := []*svcapitypes.ContainerDefinition{}
		for _, f1iter := range resp.TaskDefinition.ContainerDefinitions {
			f1elem := &svcapitypes.ContainerDefinition{}
			if f1iter.Command != nil {
				f1elem.Command = aws.StringSlice(f1iter.Command)
			}
			cpuCopy := int64(f1iter.Cpu)
			f1elem.CPU = &cpuCopy
			if f1iter.CredentialSpecs != nil {
				f1elem.CredentialSpecs = aws.StringSlice(f1iter.CredentialSpecs)
			}
			if f1iter.DependsOn != nil {
				f1elemf3 := []*svcapitypes.ContainerDependency{}
				for _, f1elemf3iter := range f1iter.DependsOn {
					f1elemf3elem := &svcapitypes.ContainerDependency{}
					if f1elemf3iter.Condition != "" {
						f1elemf3elem.Condition = aws.String(string(f1elemf3iter.Condition))
					}
					if f1elemf3iter.ContainerName != nil {
						f1elemf3elem.ContainerName = f1elemf3iter.ContainerName
					}
					f1elemf3 = append(f1elemf3, f1elemf3elem)
				}
				f1elem.DependsOn = f1elemf3
			}
			if f1iter.DisableNetworking != nil {
				f1elem.DisableNetworking = f1iter.DisableNetworking
			}
			if f1iter.DnsSearchDomains != nil {
				f1elem.DNSSearchDomains = aws.StringSlice(f1iter.DnsSearchDomains)
			}
			if f1iter.DnsServers != nil {
				f1elem.DNSServers = aws.StringSlice(f1iter.DnsServers)
			}
			if f1iter.DockerLabels != nil {
				f1elem.DockerLabels = aws.StringMap(f1iter.DockerLabels)
			}
			if f1iter.DockerSecurityOptions != nil {
				f1elem.DockerSecurityOptions = aws.StringSlice(f1iter.DockerSecurityOptions)
			}
			if f1iter.EntryPoint != nil {
				f1elem.EntryPoint = aws.StringSlice(f1iter.EntryPoint)
			}
			if f1iter.Environment != nil {
				f1elemf10 := []*svcapitypes.KeyValuePair{}
				for _, f1elemf10iter := range f1iter.Environment {
					f1elemf10elem := &svcapitypes.KeyValuePair{}
					if f1elemf10iter.Name != nil {
						f1elemf10elem.Name = f1elemf10iter.Name
					}
					if f1elemf10iter.Value != nil {
						f1elemf10elem.Value = f1elemf10iter.Value
					}
					f1elemf10 = append(f1elemf10, f1elemf10elem)
				}
				f1elem.Environment = f1elemf10
			}
			if f1iter.EnvironmentFiles != nil {
				f1elemf11 := []*svcapitypes.EnvironmentFile{}
				for _, f1elemf11iter := range f1iter.EnvironmentFiles {
					f1elemf11elem := &svcapitypes.EnvironmentFile{}
					if f1elemf11iter.Type != "" {
						f1elemf11elem.Type = aws.String(string(f1elemf11iter.Type))
					}
					if f1elemf11iter.Value != nil {
						f1elemf11elem.Value = f1elemf11iter.Value
					}
					f1elemf11 = append(f1elemf11, f1elemf11elem)
				}
				f1elem.EnvironmentFiles = f1elemf11
			}
			if f1iter.Essential != nil {
				f1elem.Essential = f1iter.Essential
			}
			if f1iter.ExtraHosts != nil {
				f1elemf13 := []*svcapitypes.HostEntry{}
				for _, f1elemf13iter := range f1iter.ExtraHosts {
					f1elemf13elem := &svcapitypes.HostEntry{}
					if f1elemf13iter.Hostname != nil {
						f1elemf13elem.Hostname = f1elemf13iter.Hostname
					}
					if f1elemf13iter.IpAddress != nil {
						f1elemf13elem.IPAddress = f1elemf13iter.IpAddress
					}
					f1elemf13 = append(f1elemf13, f1elemf13elem)
				}
				f1elem.ExtraHosts = f1elemf13
			}
			if f1iter.FirelensConfiguration != nil {
				f1elemf14 := &svcapitypes.FirelensConfiguration{}
				if f1iter.FirelensConfiguration.Options != nil {
					f1elemf14.Options = aws.StringMap(f1iter.FirelensConfiguration.Options)
				}
				if f1iter.FirelensConfiguration.Type != "" {
					f1elemf14.Type = aws.String(string(f1iter.FirelensConfiguration.Type))
				}
				f1elem.FirelensConfiguration = f1elemf14
			}
			if f1iter.HealthCheck != nil {
				f1elemf15 := &svcapitypes.HealthCheck{}
				if f1iter.HealthCheck.Command != nil {
					f1elemf15.Command = aws.StringSlice(f1iter.HealthCheck.Command)
				}
				if f1iter.HealthCheck.Interval != nil {
					intervalCopy := int64(*f1iter.HealthCheck.Interval)
					f1elemf15.Interval = &intervalCopy
				}
				if f1iter.HealthCheck.Retries != nil {
					retriesCopy := int64(*f1iter.HealthCheck.Retries)
					f1elemf15.Retries = &retriesCopy
				}
				if f1iter.HealthCheck.StartPeriod != nil {
					startPeriodCopy := int64(*f1iter.HealthCheck.StartPeriod)
					f1elemf15.StartPeriod = &startPeriodCopy
				}
				if f1iter.HealthCheck.Timeout != nil {
					timeoutCopy := int64(*f1iter.HealthCheck.Timeout)
					f1elemf15.Timeout = &timeoutCopy
				}
				f1elem.HealthCheck = f1elemf15
			}
			if f1iter.Hostname != nil {
				f1elem.Hostname = f1iter.Hostname
			}
			if f1iter.Image != nil {
				f1elem.Image = f1iter.Image
			}
			if f1iter.Interactive != nil {
				f1elem.Interactive = f1iter.Interactive
			}
			if f1iter.Links != nil {
				f1elem.Links = aws.StringSlice(f1iter.Links)
			}
			if f1iter.LinuxParameters != nil {
				f1elemf20 := &svcapitypes.LinuxParameters{}
				if f1iter.LinuxParameters.Capabilities != nil {
					f1elemf20f0 := &svcapitypes.KernelCapabilities{}
					if f1iter.LinuxParameters.Capabilities.Add != nil {
						f1elemf20f0.Add = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Add)
					}
					if f1iter.LinuxParameters.Capabilities.Drop != nil {
						f1elemf20f0.Drop = aws.StringSlice(f1iter.LinuxParameters.Capabilities.Drop)
					}
					f1elemf20.Capabilities = f1elemf20f0
				}
				if f1iter.LinuxParameters.Devices != nil {
					f1elemf20f1 := []*svcapitypes.Device{}
					for _, f1elemf20f1iter := range f1iter.LinuxParameters.Devices {
						f1elemf20f1elem := &svcapitypes.Device{}
						if f1elemf20f1iter.ContainerPath != nil {
							f1elemf20f1elem.ContainerPath = f1elemf20f1iter.ContainerPath
						}
						if f1elemf20f1iter.HostPath != nil {
							f1elemf20f1elem.HostPath = f1elemf20f1iter.HostPath
						}
						if f1elemf20f1iter.Permissions != nil {
							f1elemf20f1elemf2 := []*string{}
							for _, f1elemf20f1elemf2iter := range f1elemf20f1iter.Permissions {
								var f1elemf20f1elemf2elem *string
								f1elemf20f1elemf2elem = aws.String(string(f1elemf20f1elemf2iter))
								f1elemf20f1elemf2 = append(f1elemf20f1elemf2, f1elemf20f1elemf2elem)
							}
							f1elemf20f1elem.Permissions = f1elemf20f1elemf2
						}
						f1elemf20f1 = append(f1elemf20f1, f1elemf20f1elem)
					}
					f1elemf20.Devices = f1elemf20f1
				}
				if f1iter.LinuxParameters.InitProcessEnabled != nil {
					f1elemf20.InitProcessEnabled = f1iter.LinuxParameters.InitProcessEnabled
				}
				if f1iter.LinuxParameters.MaxSwap != nil {
					maxSwapCopy := int64(*f1iter.LinuxParameters.MaxSwap)
					f1elemf20.MaxSwap = &maxSwapCopy
				}
				if f1iter.LinuxParameters.SharedMemorySize != nil {
					sharedMemorySizeCopy := int64(*f1iter.LinuxParameters.SharedMemorySize)
					f1elemf20.SharedMemorySize = &sharedMemorySizeCopy
				}
				if f1iter.LinuxParameters.Swappiness != nil {
					swappinessCopy := int64(*f1iter.LinuxParameters.Swappiness)
					f1elemf20.Swappiness = &swappinessCopy
				}
				if f1iter.LinuxParameters.Tmpfs != nil {
					f1elemf20f6 := []*svcapitypes.Tmpfs{}
					for _, f1elemf20f6iter := range f1iter.LinuxParameters.Tmpfs {
						f1elemf20f6elem := &svcapitypes.Tmpfs{}
						if f1elemf20f6iter.ContainerPath != nil {
							f1elemf20f6elem.ContainerPath = f1elemf20f6iter.ContainerPath
						}
						if f1elemf20f6iter.MountOptions != nil {
							f1elemf20f6elem.MountOptions = aws.StringSlice(f1elemf20f6iter.MountOptions)
						}
						sizeCopy := int64(f1elemf20f6iter.Size)
						f1elemf20f6elem.Size = &sizeCopy
						f1elemf20f6 = append(f1elemf20f6, f1elemf20f6elem)
					}
					f1elemf20.Tmpfs = f1elemf20f6
				}
				f1elem.LinuxParameters = f1elemf20
			}
			if f1iter.LogConfiguration != nil {
				f1elemf21 := &svcapitypes.LogConfiguration{}
				if f1iter.LogConfiguration.LogDriver != "" {
					f1elemf21.LogDriver = aws.String(string(f1iter.LogConfiguration.LogDriver))
				}
				if f1iter.LogConfiguration.Options != nil {
					f1elemf21.Options = aws.StringMap(f1iter.LogConfiguration.Options)
				}
				if f1iter.LogConfiguration.SecretOptions != nil {
					f1elemf21f2 := []*svcapitypes.Secret{}
					for _, f1elemf21f2iter := range f1iter.LogConfiguration.SecretOptions {
						f1elemf21f2elem := &svcapitypes.Secret{}
						if f1elemf21f2iter.Name != nil {
							f1elemf21f2elem.Name = f1elemf21f2iter.Name
						}
						if f1elemf21f2iter.ValueFrom != nil {
							f1elemf21f2elem.ValueFrom = f1elemf21f2iter.ValueFrom
						}
						f1elemf21f2 = append(f1elemf21f2, f1elemf21f2elem)
					}
					f1elemf21.SecretOptions = f1elemf21f2
				}
				f1elem.LogConfiguration = f1elemf21
			}
			if f1iter.Memory != nil {
				memoryCopy := int64(*f1iter.Memory)
				f1elem.Memory = &memoryCopy
			}
			if f1iter.MemoryReservation != nil {
				memoryReservationCopy := int64(*f1iter.MemoryReservation)
				f1elem.MemoryReservation = &memoryReservationCopy
			}
			if f1iter.MountPoints != nil {
				f1elemf24 := []*svcapitypes.MountPoint{}
				for _, f1elemf24iter := range f1iter.MountPoints {
					f1elemf24elem := &svcapitypes.MountPoint{}
					if f1elemf24iter.ContainerPath != nil {
						f1elemf24elem.ContainerPath = f1elemf24iter.ContainerPath
					}
					if f1elemf24iter.ReadOnly != nil {
						f1elemf24elem.ReadOnly = f1elemf24iter.ReadOnly
					}
					if f1elemf24iter.SourceVolume != nil {
						f1elemf24elem.SourceVolume = f1elemf24iter.SourceVolume
					}
					f1elemf24 = append(f1elemf24, f1elemf24elem)
				}
				f1elem.MountPoints = f1elemf24
			}
			if f1iter.Name != nil {
				f1elem.Name = f1iter.Name
			}
			if f1iter.PortMappings != nil {
				f1elemf26 := []*svcapitypes.PortMapping{}
				for _, f1elemf26iter := range f1iter.PortMappings {
					f1elemf26elem := &svcapitypes.PortMapping{}
					if f1elemf26iter.AppProtocol != "" {
						f1elemf26elem.AppProtocol = aws.String(string(f1elemf26iter.AppProtocol))
					}
					if f1elemf26iter.ContainerPort != nil {
						containerPortCopy := int64(*f1elemf26iter.ContainerPort)
						f1elemf26elem.ContainerPort = &containerPortCopy
					}
					if f1elemf26iter.ContainerPortRange != nil {
						f1elemf26elem.ContainerPortRange = f1elemf26iter.ContainerPortRange
					}
					if f1elemf26iter.HostPort != nil {
						hostPortCopy := int64(*f1elemf26iter.HostPort)
						f1elemf26elem.HostPort = &hostPortCopy
					}
					if f1elemf26iter.Name != nil {
						f1elemf26elem.Name = f1elemf26iter.Name
					}
					if f1elemf26iter.Protocol != "" {
						f1elemf26elem.Protocol = aws.String(string(f1elemf26iter.Protocol))
					}
					f1elemf26 = append(f1elemf26, f1elemf26elem)
				}
				f1elem.PortMappings = f1elemf26
			}
			if f1iter.Privileged != nil {
				f1elem.Privileged = f1iter.Privileged
			}
			if f1iter.PseudoTerminal != nil {
				f1elem.PseudoTerminal = f1iter.PseudoTerminal
			}
			if f1iter.ReadonlyRootFilesystem != nil {
				f1elem.ReadonlyRootFilesystem = f1iter.ReadonlyRootFilesystem
			}
			if f1iter.RepositoryCredentials != nil {
				f1elemf30 := &svcapitypes.RepositoryCredentials{}
				if f1iter.RepositoryCredentials.CredentialsParameter != nil {
					f1elemf30.CredentialsParameter = f1iter.RepositoryCredentials.CredentialsParameter
				}
				f1elem.RepositoryCredentials = f1elemf30
			}
			if f1iter.ResourceRequirements != nil {
				f1elemf31 := []*svcapitypes.ResourceRequirement{}
				for _, f1elemf31iter := range f1iter.ResourceRequirements {
					f1elemf31elem := &svcapitypes.ResourceRequirement{}
					if f1elemf31iter.Type != "" {
						f1elemf31elem.Type = aws.String(string(f1elemf31iter.Type))
					}
					if f1elemf31iter.Value != nil {
						f1elemf31elem.Value = f1elemf31iter.Value
					}
					f1elemf31 = append(f1elemf31, f1elemf31elem)
				}
				f1elem.ResourceRequirements = f1elemf31
			}
			if f1iter.Secrets != nil {
				f1elemf32 := []*svcapitypes.Secret{}
				for _, f1elemf32iter := range f1iter.Secrets {
					f1elemf32elem := &svcapitypes.Secret{}
					if f1elemf32iter.Name != nil {
						f1elemf32elem.Name = f1elemf32iter.Name
					}
					if f1elemf32iter.ValueFrom != nil {
						f1elemf32elem.ValueFrom = f1elemf32iter.ValueFrom
					}
					f1elemf32 = append(f1elemf32, f1elemf32elem)
				}
				f1elem.Secrets = f1elemf32
			}
			if f1iter.StartTimeout != nil {
				startTimeoutCopy := int64(*f1iter.StartTimeout)
				f1elem.StartTimeout = &startTimeoutCopy
			}
			if f1iter.StopTimeout != nil {
				stopTimeoutCopy := int64(*f1iter.StopTimeout)
				f1elem.StopTimeout = &stopTimeoutCopy
			}
			if f1iter.SystemControls != nil {
				f1elemf35 := []*svcapitypes.SystemControl{}
				for _, f1elemf35iter := range f1iter.SystemControls {
					f1elemf35elem := &svcapitypes.SystemControl{}
					if f1elemf35iter.Namespace != nil {
						f1elemf35elem.Namespace = f1elemf35iter.Namespace
					}
					if f1elemf35iter.Value != nil {
						f1elemf35elem.Value = f1elemf35iter.Value
					}
					f1elemf35 = append(f1elemf35, f1elemf35elem)
				}
				f1elem.SystemControls = f1elemf35
			}
			if f1iter.Ulimits != nil {
				f1elemf36 := []*svcapitypes.Ulimit{}
				for _, f1elemf36iter := range f1iter.Ulimits {
					f1elemf36elem := &svcapitypes.Ulimit{}
					hardLimitCopy := int64(f1elemf36iter.HardLimit)
					f1elemf36elem.HardLimit = &hardLimitCopy
					if f1elemf36iter.Name != "" {
						f1elemf36elem.Name = aws.String(string(f1elemf36iter.Name))
					}
					softLimitCopy := int64(f1elemf36iter.SoftLimit)
					f1elemf36elem.SoftLimit = &softLimitCopy
					f1elemf36 = append(f1elemf36, f1elemf36elem)
				}
				f1elem.Ulimits = f1elemf36
			}
			if f1iter.User != nil {
				f1elem.User = f1iter.User
			}
			if f1iter.VolumesFrom != nil {
				f1elemf38 := []*svcapitypes.VolumeFrom{}
				for _, f1elemf38iter := range f1iter.VolumesFrom {
					f1elemf38elem := &svcapitypes.VolumeFrom{}
					if f1elemf38iter.ReadOnly != nil {
						f1elemf38elem.ReadOnly = f1elemf38iter.ReadOnly
					}
					if f1elemf38iter.SourceContainer != nil {
						f1elemf38elem.SourceContainer = f1elemf38iter.SourceContainer
					}
					f1elemf38 = append(f1elemf38, f1elemf38elem)
				}
				f1elem.VolumesFrom = f1elemf38
			}
			if f1iter.WorkingDirectory != nil {
				f1elem.WorkingDirectory = f1iter.WorkingDirectory
			}
			f1 = append(f1, f1elem)
		}
		ko.Spec.ContainerDefinitions = f1
	} else {
		ko.Spec.ContainerDefinitions = nil
	}
	if resp.TaskDefinition.Cpu != nil {
		ko.Spec.CPU = resp.TaskDefinition.Cpu
	} else {
		ko.Spec.CPU = nil
	}
	if resp.TaskDefinition.DeregisteredAt != nil {
		ko.Status.DeregisteredAt = &metav1.Time{*resp.TaskDefinition.DeregisteredAt}
	} else {
		ko.Status.DeregisteredAt = nil
	}
	if resp.TaskDefinition.EphemeralStorage != nil {
		f4 := &svcapitypes.EphemeralStorage{}
		sizeInGiBCopy := int64(resp.TaskDefinition.EphemeralStorage.SizeInGiB)
		f4.SizeInGiB = &sizeInGiBCopy
		ko.Spec.EphemeralStorage = f4
	} else {
		ko.Spec.EphemeralStorage = nil
	}
	if resp.TaskDefinition.ExecutionRoleArn != nil {
		ko.Spec.ExecutionRoleARN = resp.TaskDefinition.ExecutionRoleArn
	} else {
		ko.Spec.ExecutionRoleARN = nil
	}
	if resp.TaskDefinition.Family != nil {
		ko.Spec.Family = resp.TaskDefinition.Family
	} else {
		ko.Spec.Family = nil
	}
	if resp.TaskDefinition.InferenceAccelerators != nil {
		f7 := []*svcapitypes.InferenceAccelerator{}
		for _, f7iter := range resp.TaskDefinition.InferenceAccelerators {
			f7elem := &svcapitypes.InferenceAccelerator{}
			if f7iter.DeviceName != nil {
				f7elem.DeviceName = f7iter.DeviceName
			}
			if f7iter.DeviceType != nil {
				f7elem.DeviceType = f7iter.DeviceType
			}
			f7 = append(f7, f7elem)
		}
		ko.Spec.InferenceAccelerators = f7
	} else {
		ko.Spec.InferenceAccelerators = nil
	}
	if resp.TaskDefinition.IpcMode != "" {
		ko.Spec.IPCMode = aws.String(string(resp.TaskDefinition.IpcMode))
	} else {
		ko.Spec.IPCMode = nil
	}
	if resp.TaskDefinition.Memory != nil {
		ko.Spec.Memory = resp.TaskDefinition.Memory
	} else {
		ko.Spec.Memory = nil
	}
	if resp.TaskDefinition.NetworkMode != "" {
		ko.Spec.NetworkMode = aws.String(string(resp.TaskDefinition.NetworkMode))
	} else {
		ko.Spec.NetworkMode = nil
	}
	if resp.TaskDefinition.PidMode != "" {
		ko.Spec.PIDMode = aws.String(string(resp.TaskDefinition.PidMode))
	} else {
		ko.Spec.PIDMode = nil
	}
	if resp.TaskDefinition.PlacementConstraints != nil {
		f12 := []*svcapitypes.TaskDefinitionPlacementConstraint{}
		for _, f12iter := range resp.TaskDefinition.PlacementConstraints {
			f12elem := &svcapitypes.TaskDefinitionPlacementConstraint{}
			if f12iter.Expression != nil {
				f12elem.Expression = f12iter.Expression
			}
			if f12iter.Type != "" {
				f12elem.Type = aws.String(string(f12iter.Type))
			}
			f12 = append(f12, f12elem)
		}
		ko.Spec.PlacementConstraints = f12
	} else {
		ko.Spec.PlacementConstraints = nil
	}
	if resp.TaskDefinition.ProxyConfiguration != nil {
		f13 := &svcapitypes.ProxyConfiguration{}
		if resp.TaskDefinition.ProxyConfiguration.ContainerName != nil {
			f13.ContainerName = resp.TaskDefinition.ProxyConfiguration.ContainerName
		}
		if resp.TaskDefinition.ProxyConfiguration.Properties != nil {
			f13f1 := []*svcapitypes.KeyValuePair{}
			for _, f13f1iter := range resp.TaskDefinition.ProxyConfiguration.Properties {
				f13f1elem := &svcapitypes.KeyValuePair{}
				if f13f1iter.Name != nil {
					f13f1elem.Name = f13f1iter.Name
				}
				if f13f1iter.Value != nil {
					f13f1elem.Value = f13f1iter.Value
				}
				f13f1 = append(f13f1, f13f1elem)
			}
			f13.Properties = f13f1
		}
		if resp.TaskDefinition.ProxyConfiguration.Type != "" {
			f13.Type = aws.String(string(resp.TaskDefinition.ProxyConfiguration.Type))
		}
		ko.Spec.ProxyConfiguration = f13
	} else {
		ko.Spec.ProxyConfiguration = nil
	}
	if resp.TaskDefinition.RegisteredAt != nil {
		ko.Status.RegisteredAt = &metav1.Time{*resp.TaskDefinition.RegisteredAt}
	} else {
		ko.Status.RegisteredAt = nil
	}
	if resp.TaskDefinition.RegisteredBy != nil {
		ko.Status.RegisteredBy = resp.TaskDefinition.RegisteredBy
	} else {
		ko.Status.RegisteredBy = nil
	}
	if resp.TaskDefinition.RequiresAttributes != nil {
		f16 := []*svcapitypes.Attribute{}
		for _, f16iter := range resp.TaskDefinition.RequiresAttributes {
			f16elem := &svcapitypes.Attribute{}
			if f16iter.Name != nil {
				f16elem.Name = f16iter.Name
			}
			if f16iter.TargetId != nil {
				f16elem.TargetID = f16iter.TargetId
			}
			if f16iter.TargetType != "" {
				f16elem.TargetType = aws.String(string(f16iter.TargetType))
			}
			if f16iter.Value != nil {
				f16elem.Value = f16iter.Value
			}
			f16 = append(f16, f16elem)
		}
		ko.Status.RequiresAttributes = f16
	} else {
		ko.Status.RequiresAttributes = nil
	}
	if resp.TaskDefinition.RequiresCompatibilities != nil {
		f17 := []*string{}
		for _, f17iter := range resp.TaskDefinition.RequiresCompatibilities {
			var f17elem *string
			f17elem = aws.String(string(f17iter))
			f17 = append(f17, f17elem)
		}
		ko.Spec.RequiresCompatibilities = f17
	} else {
		ko.Spec.RequiresCompatibilities = nil
	}
	revisionCopy := int64(resp.TaskDefinition.Revision)
	ko.Status.Revision = &revisionCopy
	if resp.TaskDefinition.RuntimePlatform != nil {
		f19 := &svcapitypes.RuntimePlatform{}
		if resp.TaskDefinition.RuntimePlatform.CpuArchitecture != "" {
			f19.CPUArchitecture = aws.String(string(resp.TaskDefinition.RuntimePlatform.CpuArchitecture))
		}
		if resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily != "" {
			f19.OperatingSystemFamily = aws.String(string(resp.TaskDefinition.RuntimePlatform.OperatingSystemFamily))
		}
		ko.Spec.RuntimePlatform = f19
	} else {
		ko.Spec.RuntimePlatform = nil
	}
	if resp.TaskDefinition.Status != "" {
		ko.Status.Status = aws.String(string(resp.TaskDefinition.Status))
	} else {
		ko.Status.Status = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TaskDefinition.TaskDefinitionArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TaskDefinition.TaskDefinitionArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.TaskDefinition.TaskRoleArn != nil {
		ko.Spec.TaskRoleARN = resp.TaskDefinition.TaskRoleArn
	} else {
		ko.Spec.TaskRoleARN = nil
	}
	if resp.TaskDefinition.Volumes != nil {
		f23 := []*svcapitypes.Volume{}
		for _, f23iter := range resp.TaskDefinition.Volumes {
			f23elem := &svcapitypes.Volume{}
			if f23iter.ConfiguredAtLaunch != nil {
				f23elem.ConfiguredAtLaunch = f23iter.ConfiguredAtLaunch
			}
			if f23iter.DockerVolumeConfiguration != nil {
				f23elemf1 := &svcapitypes.DockerVolumeConfiguration{}
				if f23iter.DockerVolumeConfiguration.Autoprovision != nil {
					f23elemf1.Autoprovision = f23iter.DockerVolumeConfiguration.Autoprovision
				}
				if f23iter.DockerVolumeConfiguration.Driver != nil {
					f23elemf1.Driver = f23iter.DockerVolumeConfiguration.Driver
				}
				if f23iter.DockerVolumeConfiguration.DriverOpts != nil {
					f23elemf1.DriverOpts = aws.StringMap(f23iter.DockerVolumeConfiguration.DriverOpts)
				}
				if f23iter.DockerVolumeConfiguration.Labels != nil {
					f23elemf1.Labels = aws.StringMap(f23iter.DockerVolumeConfiguration.Labels)
				}
				if f23iter.DockerVolumeConfiguration.Scope != "" {
					f23elemf1.Scope = aws.String(string(f23iter.DockerVolumeConfiguration.Scope))
				}
				f23elem.DockerVolumeConfiguration = f23elemf1
			}
			if f23iter.EfsVolumeConfiguration != nil {
				f23elemf2 := &svcapitypes.EFSVolumeConfiguration{}
				if f23iter.EfsVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf2f0 := &svcapitypes.EFSAuthorizationConfig{}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId != nil {
						f23elemf2f0.AccessPointID = f23iter.EfsVolumeConfiguration.AuthorizationConfig.AccessPointId
					}
					if f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam != "" {
						f23elemf2f0.IAM = aws.String(string(f23iter.EfsVolumeConfiguration.AuthorizationConfig.Iam))
					}
					f23elemf2.AuthorizationConfig = f23elemf2f0
				}
				if f23iter.EfsVolumeConfiguration.FileSystemId != nil {
					f23elemf2.FileSystemID = f23iter.EfsVolumeConfiguration.FileSystemId
				}
				if f23iter.EfsVolumeConfiguration.RootDirectory != nil {
					f23elemf2.RootDirectory = f23iter.EfsVolumeConfiguration.RootDirectory
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryption != "" {
					f23elemf2.TransitEncryption = aws.String(string(f23iter.EfsVolumeConfiguration.TransitEncryption))
				}
				if f23iter.EfsVolumeConfiguration.TransitEncryptionPort != nil {
					transitEncryptionPortCopy := int64(*f23iter.EfsVolumeConfiguration.TransitEncryptionPort)
					f23elemf2.TransitEncryptionPort = &transitEncryptionPortCopy
				}
				f23elem.EFSVolumeConfiguration = f23elemf2
			}
			if f23iter.FsxWindowsFileServerVolumeConfiguration != nil {
				f23elemf3 := &svcapitypes.FSxWindowsFileServerVolumeConfiguration{}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
					f23elemf3f0 := &svcapitypes.FSxWindowsFileServerAuthorizationConfig{}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
						f23elemf3f0.CredentialsParameter = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter
					}
					if f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
						f23elemf3f0.Domain = f23iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain
					}
					f23elemf3.AuthorizationConfig = f23elemf3f0
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId != nil {
					f23elemf3.FileSystemID = f23iter.FsxWindowsFileServerVolumeConfiguration.FileSystemId
				}
				if f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
					f23elemf3.RootDirectory = f23iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory
				}
				f23elem.FsxWindowsFileServerVolumeConfiguration = f23elemf3
			}
			if f23iter.Host != nil {
				f23elemf4 := &svcapitypes.HostVolumeProperties{}
				if f23iter.Host.SourcePath != nil {
					f23elemf4.SourcePath = f23iter.Host.SourcePath
				}
				f23elem.Host = f23elemf4
			}
			if f23iter.Name != nil {
				f23elem.Name = f23iter.Name
			}
			f23 = append(f23, f23elem)
		}
		ko.Spec.Volumes = f23
	} else {
		ko.Spec.Volumes = nil
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// newUpdateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Update API call for the resource
func (rm *resourceManager) newUpdateRequestPayload(
	ctx context.Context,
	r *resource,
	delta *ackcompare.Delta,
) (*svcsdk.RegisterTaskDefinitionInput, error) {
	res := &svcsdk.RegisterTaskDefinitionInput{}

	if r.ko.Spec.ContainerDefinitions != nil {
		f0 := []svcsdktypes.ContainerDefinition{}
		for _, f0iter := range r.ko.Spec.ContainerDefinitions {
			f0elem := &svcsdktypes.ContainerDefinition{}
			if f0iter.Command != nil {
				f0elem.Command = aws.ToStringSlice(f0iter.Command)
			}
			if f0iter.CPU != nil {
				cpuCopy0 := *f0iter.CPU
				if cpuCopy0 > math.MaxInt32 || cpuCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field cpu is of type int32")
				}
				cpuCopy := int32(cpuCopy0)
				f0elem.Cpu = cpuCopy
			}
			if f0iter.CredentialSpecs != nil {
				f0elem.CredentialSpecs = aws.ToStringSlice(f0iter.CredentialSpecs)
			}
			if f0iter.DependsOn != nil {
				f0elemf3 := []svcsdktypes.ContainerDependency{}
				for _, f0elemf3iter := range f0iter.DependsOn {
					f0elemf3elem := &svcsdktypes.ContainerDependency{}
					if f0elemf3iter.Condition != nil {
						f0elemf3elem.Condition = svcsdktypes.ContainerCondition(*f0elemf3iter.Condition)
					}
					if f0elemf3iter.ContainerName != nil {
						f0elemf3elem.ContainerName = f0elemf3iter.ContainerName
					}
					f0elemf3 = append(f0elemf3, *f0elemf3elem)
				}
				f0elem.DependsOn = f0elemf3
			}
			if f0iter.DisableNetworking != nil {
				f0elem.DisableNetworking = f0iter.DisableNetworking
			}
			if f0iter.DNSSearchDomains != nil {
				f0elem.DnsSearchDomains = aws.ToStringSlice(f0iter.DNSSearchDomains)
			}
			if f0iter.DNSServers != nil {
				f0elem.DnsServers = aws.ToStringSlice(f0iter.DNSServers)
			}
			if f0iter.DockerLabels != nil {
				f0elem.DockerLabels = aws.ToStringMap(f0iter.DockerLabels)
			}
			if f0iter.DockerSecurityOptions != nil {
				f0elem.DockerSecurityOptions = aws.ToStringSlice(f0iter.DockerSecurityOptions)
			}
			if f0iter.EntryPoint != nil {
				f0elem.EntryPoint = aws.ToStringSlice(f0iter.EntryPoint)
			}
			if f0iter.Environment != nil {
				f0elemf10 := []svcsdktypes.KeyValuePair{}
				for _, f0elemf10iter := range f0iter.Environment {
					f0elemf10elem := &svcsdktypes.KeyValuePair{}
					if f0elemf10iter.Name != nil {
						f0elemf10elem.Name = f0elemf10iter.Name
					}
					if f0elemf10iter.Value != nil {
						f0elemf10elem.Value = f0elemf10iter.Value
					}
					f0elemf10 = append(f0elemf10, *f0elemf10elem)
				}
				f0elem.Environment = f0elemf10
			}
			if f0iter.EnvironmentFiles != nil {
				f0elemf11 := []svcsdktypes.EnvironmentFile{}
				for _, f0elemf11iter := range f0iter.EnvironmentFiles {
					f0elemf11elem := &svcsdktypes.EnvironmentFile{}
					if f0elemf11iter.Type != nil {
						f0elemf11elem.Type = svcsdktypes.EnvironmentFileType(*f0elemf11iter.Type)
					}
					if f0elemf11iter.Value != nil {
						f0elemf11elem.Value = f0elemf11iter.Value
					}
					f0elemf11 = append(f0elemf11, *f0elemf11elem)
				}
				f0elem.EnvironmentFiles = f0elemf11
			}
			if f0iter.Essential != nil {
				f0elem.Essential = f0iter.Essential
			}
			if f0iter.ExtraHosts != nil {
				f0elemf13 := []svcsdktypes.HostEntry{}
				for _, f0elemf13iter := range f0iter.ExtraHosts {
					f0elemf13elem := &svcsdktypes.HostEntry{}
					if f0elemf13iter.Hostname != nil {
						f0elemf13elem.Hostname = f0elemf13iter.Hostname
					}
					if f0elemf13iter.IPAddress != nil {
						f0elemf13elem.IpAddress = f0elemf13iter.IPAddress
					}
					f0elemf13 = append(f0elemf13, *f0elemf13elem)
				}
				f0elem.ExtraHosts = f0elemf13
			}
			if f0iter.FirelensConfiguration != nil {
				f0elemf14 := &svcsdktypes.FirelensConfiguration{}
				if f0iter.FirelensConfiguration.Options != nil {
					f0elemf14.Options = aws.ToStringMap(f0iter.FirelensConfiguration.Options)
				}
				if f0iter.FirelensConfiguration.Type != nil {
					f0elemf14.Type = svcsdktypes.FirelensConfigurationType(*f0iter.FirelensConfiguration.Type)
				}
				f0elem.FirelensConfiguration = f0elemf14
			}
			if f0iter.HealthCheck != nil {
				f0elemf15 := &svcsdktypes.HealthCheck{}
				if f0iter.HealthCheck.Command != nil {
					f0elemf15.Command = aws.ToStringSlice(f0iter.HealthCheck.Command)
				}
				if f0iter.HealthCheck.Interval != nil {
					intervalCopy0 := *f0iter.HealthCheck.Interval
					if intervalCopy0 > math.MaxInt32 || intervalCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field interval is of type int32")
					}
					intervalCopy := int32(intervalCopy0)
					f0elemf15.Interval = &intervalCopy
				}
				if f0iter.HealthCheck.Retries != nil {
					retriesCopy0 := *f0iter.HealthCheck.Retries
					if retriesCopy0 > math.MaxInt32 || retriesCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field retries is of type int32")
					}
					retriesCopy := int32(retriesCopy0)
					f0elemf15.Retries = &retriesCopy
				}
				if f0iter.HealthCheck.StartPeriod != nil {
					startPeriodCopy0 := *f0iter.HealthCheck.StartPeriod
					if startPeriodCopy0 > math.MaxInt32 || startPeriodCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field startPeriod is of type int32")
					}
					startPeriodCopy := int32(startPeriodCopy0)
					f0elemf15.StartPeriod = &startPeriodCopy
				}
				if f0iter.HealthCheck.Timeout != nil {
					timeoutCopy0 := *f0iter.HealthCheck.Timeout
					if timeoutCopy0 > math.MaxInt32 || timeoutCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field timeout is of type int32")
					}
					timeoutCopy := int32(timeoutCopy0)
					f0elemf15.Timeout = &timeoutCopy
				}
				f0elem.HealthCheck = f0elemf15
			}
			if f0iter.Hostname != nil {
				f0elem.Hostname = f0iter.Hostname
			}
			if f0iter.Image != nil {
				f0elem.Image = f0iter.Image
			}
			if f0iter.Interactive != nil {
				f0elem.Interactive = f0iter.Interactive
			}
			if f0iter.Links != nil {
				f0elem.Links = aws.ToStringSlice(f0iter.Links)
			}
			if f0iter.LinuxParameters != nil {
				f0elemf20 := &svcsdktypes.LinuxParameters{}
				if f0iter.LinuxParameters.Capabilities != nil {
					f0elemf20f0 := &svcsdktypes.KernelCapabilities{}
					if f0iter.LinuxParameters.Capabilities.Add != nil {
						f0elemf20f0.Add = aws.ToStringSlice(f0iter.LinuxParameters.Capabilities.Add)
					}
					if f0iter.LinuxParameters.Capabilities.Drop != nil {
						f0elemf20f0.Drop = aws.ToStringSlice(f0iter.LinuxParameters.Capabilities.Drop)
					}
					f0elemf20.Capabilities = f0elemf20f0
				}
				if f0iter.LinuxParameters.Devices != nil {
					f0elemf20f1 := []svcsdktypes.Device{}
					for _, f0elemf20f1iter := range f0iter.LinuxParameters.Devices {
						f0elemf20f1elem := &svcsdktypes.Device{}
						if f0elemf20f1iter.ContainerPath != nil {
							f0elemf20f1elem.ContainerPath = f0elemf20f1iter.ContainerPath
						}
						if f0elemf20f1iter.HostPath != nil {
							f0elemf20f1elem.HostPath = f0elemf20f1iter.HostPath
						}
						if f0elemf20f1iter.Permissions != nil {
							f0elemf20f1elemf2 := []svcsdktypes.DeviceCgroupPermission{}
							for _, f0elemf20f1elemf2iter := range f0elemf20f1iter.Permissions {
								var f0elemf20f1elemf2elem string
								f0elemf20f1elemf2elem = string(*f0elemf20f1elemf2iter)
								f0elemf20f1elemf2 = append(f0elemf20f1elemf2, svcsdktypes.DeviceCgroupPermission(f0elemf20f1elemf2elem))
							}
							f0elemf20f1elem.Permissions = f0elemf20f1elemf2
						}
						f0elemf20f1 = append(f0elemf20f1, *f0elemf20f1elem)
					}
					f0elemf20.Devices = f0elemf20f1
				}
				if f0iter.LinuxParameters.InitProcessEnabled != nil {
					f0elemf20.InitProcessEnabled = f0iter.LinuxParameters.InitProcessEnabled
				}
				if f0iter.LinuxParameters.MaxSwap != nil {
					maxSwapCopy0 := *f0iter.LinuxParameters.MaxSwap
					if maxSwapCopy0 > math.MaxInt32 || maxSwapCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field maxSwap is of type int32")
					}
					maxSwapCopy := int32(maxSwapCopy0)
					f0elemf20.MaxSwap = &maxSwapCopy
				}
				if f0iter.LinuxParameters.SharedMemorySize != nil {
					sharedMemorySizeCopy0 := *f0iter.LinuxParameters.SharedMemorySize
					if sharedMemorySizeCopy0 > math.MaxInt32 || sharedMemorySizeCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field sharedMemorySize is of type int32")
					}
					sharedMemorySizeCopy := int32(sharedMemorySizeCopy0)
					f0elemf20.SharedMemorySize = &sharedMemorySizeCopy
				}
				if f0iter.LinuxParameters.Swappiness != nil {
					swappinessCopy0 := *f0iter.LinuxParameters.Swappiness
					if swappinessCopy0 > math.MaxInt32 || swappinessCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field swappiness is of type int32")
					}
					swappinessCopy := int32(swappinessCopy0)
					f0elemf20.Swappiness = &swappinessCopy
				}
				if f0iter.LinuxParameters.Tmpfs != nil {
					f0elemf20f6 := []svcsdktypes.Tmpfs{}
					for _, f0elemf20f6iter := range f0iter.LinuxParameters.Tmpfs {
						f0elemf20f6elem := &svcsdktypes.Tmpfs{}
						if f0elemf20f6iter.ContainerPath != nil {
							f0elemf20f6elem.ContainerPath = f0elemf20f6iter.ContainerPath
						}
						if f0elemf20f6iter.MountOptions != nil {
							f0elemf20f6elem.MountOptions = aws.ToStringSlice(f0elemf20f6iter.MountOptions)
						}
						if f0elemf20f6iter.Size != nil {
							sizeCopy0 := *f0elemf20f6iter.Size
							if sizeCopy0 > math.MaxInt32 || sizeCopy0 < math.MinInt32 {
								return nil, fmt.Errorf("error: field size is of type int32")
							}
							sizeCopy := int32(sizeCopy0)
							f0elemf20f6elem.Size = sizeCopy
						}
						f0elemf20f6 = append(f0elemf20f6, *f0elemf20f6elem)
					}
					f0elemf20.Tmpfs = f0elemf20f6
				}
				f0elem.LinuxParameters = f0elemf20
			}
			if f0iter.LogConfiguration != nil {
				f0elemf21 := &svcsdktypes.LogConfiguration{}
				if f0iter.LogConfiguration.LogDriver != nil {
					f0elemf21.LogDriver = svcsdktypes.LogDriver(*f0iter.LogConfiguration.LogDriver)
				}
				if f0iter.LogConfiguration.Options != nil {
					f0elemf21.Options = aws.ToStringMap(f0iter.LogConfiguration.Options)
				}
				if f0iter.LogConfiguration.SecretOptions != nil {
					f0elemf21f2 := []svcsdktypes.Secret{}
					for _, f0elemf21f2iter := range f0iter.LogConfiguration.SecretOptions {
						f0elemf21f2elem := &svcsdktypes.Secret{}
						if f0elemf21f2iter.Name != nil {
							f0elemf21f2elem.Name = f0elemf21f2iter.Name
						}
						if f0elemf21f2iter.ValueFrom != nil {
							f0elemf21f2elem.ValueFrom = f0elemf21f2iter.ValueFrom
						}
						f0elemf21f2 = append(f0elemf21f2, *f0elemf21f2elem)
					}
					f0elemf21.SecretOptions = f0elemf21f2
				}
				f0elem.LogConfiguration = f0elemf21
			}
			if f0iter.Memory != nil {
				memoryCopy0 := *f0iter.Memory
				if memoryCopy0 > math.MaxInt32 || memoryCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field memory is of type int32")
				}
				memoryCopy := int32(memoryCopy0)
				f0elem.Memory = &memoryCopy
			}
			if f0iter.MemoryReservation != nil {
				memoryReservationCopy0 := *f0iter.MemoryReservation
				if memoryReservationCopy0 > math.MaxInt32 || memoryReservationCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field memoryReservation is of type int32")
				}
				memoryReservationCopy := int32(memoryReservationCopy0)
				f0elem.MemoryReservation = &memoryReservationCopy
			}
			if f0iter.MountPoints != nil {
				f0elemf24 := []svcsdktypes.MountPoint{}
				for _, f0elemf24iter := range f0iter.MountPoints {
					f0elemf24elem := &svcsdktypes.MountPoint{}
					if f0elemf24iter.ContainerPath != nil {
						f0elemf24elem.ContainerPath = f0elemf24iter.ContainerPath
					}
					if f0elemf24iter.ReadOnly != nil {
						f0elemf24elem.ReadOnly = f0elemf24iter.ReadOnly
					}
					if f0elemf24iter.SourceVolume != nil {
						f0elemf24elem.SourceVolume = f0elemf24iter.SourceVolume
					}
					f0elemf24 = append(f0elemf24, *f0elemf24elem)
				}
				f0elem.MountPoints = f0elemf24
			}
			if f0iter.Name != nil {
				f0elem.Name = f0iter.Name
			}
			if f0iter.PortMappings != nil {
				f0elemf26 := []svcsdktypes.PortMapping{}
				for _, f0elemf26iter := range f0iter.PortMappings {
					f0elemf26elem := &svcsdktypes.PortMapping{}
					if f0elemf26iter.AppProtocol != nil {
						f0elemf26elem.AppProtocol = svcsdktypes.ApplicationProtocol(*f0elemf26iter.AppProtocol)
					}
					if f0elemf26iter.ContainerPort != nil {
						containerPortCopy0 := *f0elemf26iter.ContainerPort
						if containerPortCopy0 > math.MaxInt32 || containerPortCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field containerPort is of type int32")
						}
						containerPortCopy := int32(containerPortCopy0)
						f0elemf26elem.ContainerPort = &containerPortCopy
					}
					if f0elemf26iter.ContainerPortRange != nil {
						f0elemf26elem.ContainerPortRange = f0elemf26iter.ContainerPortRange
					}
					if f0elemf26iter.HostPort != nil {
						hostPortCopy0 := *f0elemf26iter.HostPort
						if hostPortCopy0 > math.MaxInt32 || hostPortCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field hostPort is of type int32")
						}
						hostPortCopy := int32(hostPortCopy0)
						f0elemf26elem.HostPort = &hostPortCopy
					}
					if f0elemf26iter.Name != nil {
						f0elemf26elem.Name = f0elemf26iter.Name
					}
					if f0elemf26iter.Protocol != nil {
						f0elemf26elem.Protocol = svcsdktypes.TransportProtocol(*f0elemf26iter.Protocol)
					}
					f0elemf26 = append(f0elemf26, *f0elemf26elem)
				}
				f0elem.PortMappings = f0elemf26
			}
			if f0iter.Privileged != nil {
				f0elem.Privileged = f0iter.Privileged
			}
			if f0iter.PseudoTerminal != nil {
				f0elem.PseudoTerminal = f0iter.PseudoTerminal
			}
			if f0iter.ReadonlyRootFilesystem != nil {
				f0elem.ReadonlyRootFilesystem = f0iter.ReadonlyRootFilesystem
			}
			if f0iter.RepositoryCredentials != nil {
				f0elemf30 := &svcsdktypes.RepositoryCredentials{}
				if f0iter.RepositoryCredentials.CredentialsParameter != nil {
					f0elemf30.CredentialsParameter = f0iter.RepositoryCredentials.CredentialsParameter
				}
				f0elem.RepositoryCredentials = f0elemf30
			}
			if f0iter.ResourceRequirements != nil {
				f0elemf31 := []svcsdktypes.ResourceRequirement{}
				for _, f0elemf31iter := range f0iter.ResourceRequirements {
					f0elemf31elem := &svcsdktypes.ResourceRequirement{}
					if f0elemf31iter.Type != nil {
						f0elemf31elem.Type = svcsdktypes.ResourceType(*f0elemf31iter.Type)
					}
					if f0elemf31iter.Value != nil {
						f0elemf31elem.Value = f0elemf31iter.Value
					}
					f0elemf31 = append(f0elemf31, *f0elemf31elem)
				}
				f0elem.ResourceRequirements = f0elemf31
			}
			if f0iter.Secrets != nil {
				f0elemf32 := []svcsdktypes.Secret{}
				for _, f0elemf32iter := range f0iter.Secrets {
					f0elemf32elem := &svcsdktypes.Secret{}
					if f0elemf32iter.Name != nil {
						f0elemf32elem.Name = f0elemf32iter.Name
					}
					if f0elemf32iter.ValueFrom != nil {
						f0elemf32elem.ValueFrom = f0elemf32iter.ValueFrom
					}
					f0elemf32 = append(f0elemf32, *f0elemf32elem)
				}
				f0elem.Secrets = f0elemf32
			}
			if f0iter.StartTimeout != nil {
				startTimeoutCopy0 := *f0iter.StartTimeout
				if startTimeoutCopy0 > math.MaxInt32 || startTimeoutCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field startTimeout is of type int32")
				}
				startTimeoutCopy := int32(startTimeoutCopy0)
				f0elem.StartTimeout = &startTimeoutCopy
			}
			if f0iter.StopTimeout != nil {
				stopTimeoutCopy0 := *f0iter.StopTimeout
				if stopTimeoutCopy0 > math.MaxInt32 || stopTimeoutCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field stopTimeout is of type int32")
				}
				stopTimeoutCopy := int32(stopTimeoutCopy0)
				f0elem.StopTimeout = &stopTimeoutCopy
			}
			if f0iter.SystemControls != nil {
				f0elemf35 := []svcsdktypes.SystemControl{}
				for _, f0elemf35iter := range f0iter.SystemControls {
					f0elemf35elem := &svcsdktypes.SystemControl{}
					if f0elemf35iter.Namespace != nil {
						f0elemf35elem.Namespace = f0elemf35iter.Namespace
					}
					if f0elemf35iter.Value != nil {
						f0elemf35elem.Value = f0elemf35iter.Value
					}
					f0elemf35 = append(f0elemf35, *f0elemf35elem)
				}
				f0elem.SystemControls = f0elemf35
			}
			if f0iter.Ulimits != nil {
				f0elemf36 := []svcsdktypes.Ulimit{}
				for _, f0elemf36iter := range f0iter.Ulimits {
					f0elemf36elem := &svcsdktypes.Ulimit{}
					if f0elemf36iter.HardLimit != nil {
						hardLimitCopy0 := *f0elemf36iter.HardLimit
						if hardLimitCopy0 > math.MaxInt32 || hardLimitCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field hardLimit is of type int32")
						}
						hardLimitCopy := int32(hardLimitCopy0)
						f0elemf36elem.HardLimit = hardLimitCopy
					}
					if f0elemf36iter.Name != nil {
						f0elemf36elem.Name = svcsdktypes.UlimitName(*f0elemf36iter.Name)
					}
					if f0elemf36iter.SoftLimit != nil {
						softLimitCopy0 := *f0elemf36iter.SoftLimit
						if softLimitCopy0 > math.MaxInt32 || softLimitCopy0 < math.MinInt32 {
							return nil, fmt.Errorf("error: field softLimit is of type int32")
						}
						softLimitCopy := int32(softLimitCopy0)
						f0elemf36elem.SoftLimit = softLimitCopy
					}
					f0elemf36 = append(f0elemf36, *f0elemf36elem)
				}
				f0elem.Ulimits = f0elemf36
			}
			if f0iter.User != nil {
				f0elem.User = f0iter.User
			}
			if f0iter.VolumesFrom != nil {
				f0elemf38 := []svcsdktypes.VolumeFrom{}
				for _, f0elemf38iter := range f0iter.VolumesFrom {
					f0elemf38elem := &svcsdktypes.VolumeFrom{}
					if f0elemf38iter.ReadOnly != nil {
						f0elemf38elem.ReadOnly = f0elemf38iter.ReadOnly
					}
					if f0elemf38iter.SourceContainer != nil {
						f0elemf38elem.SourceContainer = f0elemf38iter.SourceContainer
					}
					f0elemf38 = append(f0elemf38, *f0elemf38elem)
				}
				f0elem.VolumesFrom = f0elemf38
			}
			if f0iter.WorkingDirectory != nil {
				f0elem.WorkingDirectory = f0iter.WorkingDirectory
			}
			f0 = append(f0, *f0elem)
		}
		res.ContainerDefinitions = f0
	}
	if r.ko.Spec.CPU != nil {
		res.Cpu = r.ko.Spec.CPU
	}
	if r.ko.Spec.EphemeralStorage != nil {
		f2 := &svcsdktypes.EphemeralStorage{}
		if r.ko.Spec.EphemeralStorage.SizeInGiB != nil {
			sizeInGiBCopy0 := *r.ko.Spec.EphemeralStorage.SizeInGiB
			if sizeInGiBCopy0 > math.MaxInt32 || sizeInGiBCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field sizeInGiB is of type int32")
			}
			sizeInGiBCopy := int32(sizeInGiBCopy0)
			f2.SizeInGiB = sizeInGiBCopy
		}
		res.EphemeralStorage = f2
	}
	if r.ko.Spec.ExecutionRoleARN != nil {
		res.ExecutionRoleArn = r.ko.Spec.ExecutionRoleARN
	}
	if r.ko.Spec.Family != nil {
		res.Family = r.ko.Spec.Family
	}
	if r.ko.Spec.InferenceAccelerators != nil {
		f5 := []svcsdktypes.InferenceAccelerator{}
		for _, f5iter := range r.ko.Spec.InferenceAccelerators {
			f5elem := &svcsdktypes.InferenceAccelerator{}
			if f5iter.DeviceName != nil {
				f5elem.DeviceName = f5iter.DeviceName
			}
			if f5iter.DeviceType != nil {
				f5elem.DeviceType = f5iter.DeviceType
			}
			f5 = append(f5, *f5elem)
		}
		res.InferenceAccelerators = f5
	}
	if r.ko.Spec.IPCMode != nil {
		res.IpcMode = svcsdktypes.IpcMode(*r.ko.Spec.IPCMode)
	}
	if r.ko.Spec.Memory != nil {
		res.Memory = r.ko.Spec.Memory
	}
	if r.ko.Spec.NetworkMode != nil {
		res.NetworkMode = svcsdktypes.NetworkMode(*r.ko.Spec.NetworkMode)
	}
	if r.ko.Spec.PIDMode != nil {
		res.PidMode = svcsdktypes.PidMode(*r.ko.Spec.PIDMode)
	}
	if r.ko.Spec.PlacementConstraints != nil {
		f10 := []svcsdktypes.TaskDefinitionPlacementConstraint{}
		for _, f10iter := range r.ko.Spec.PlacementConstraints {
			f10elem := &svcsdktypes.TaskDefinitionPlacementConstraint{}
			if f10iter.Expression != nil {
				f10elem.Expression = f10iter.Expression
			}
			if f10iter.Type != nil {
				f10elem.Type = svcsdktypes.TaskDefinitionPlacementConstraintType(*f10iter.Type)
			}
			f10 = append(f10, *f10elem)
		}
		res.PlacementConstraints = f10
	}
	if r.ko.Spec.ProxyConfiguration != nil {
		f11 := &svcsdktypes.ProxyConfiguration{}
		if r.ko.Spec.ProxyConfiguration.ContainerName != nil {
			f11.ContainerName = r.ko.Spec.ProxyConfiguration.ContainerName
		}
		if r.ko.Spec.ProxyConfiguration.Properties != nil {
			f11f1 := []svcsdktypes.KeyValuePair{}
			for _, f11f1iter := range r.ko.Spec.ProxyConfiguration.Properties {
				f11f1elem := &svcsdktypes.KeyValuePair{}
				if f11f1iter.Name != nil {
					f11f1elem.Name = f11f1iter.Name
				}
				if f11f1iter.Value != nil {
					f11f1elem.Value = f11f1iter.Value
				}
				f11f1 = append(f11f1, *f11f1elem)
			}
			f11.Properties = f11f1
		}
		if r.ko.Spec.ProxyConfiguration.Type != nil {
			f11.Type = svcsdktypes.ProxyConfigurationType(*r.ko.Spec.ProxyConfiguration.Type)
		}
		res.ProxyConfiguration = f11
	}
	if r.ko.Spec.RequiresCompatibilities != nil {
		f12 := []svcsdktypes.Compatibility{}
		for _, f12iter := range r.ko.Spec.RequiresCompatibilities {
			var f12elem string
			f12elem = string(*f12iter)
			f12 = append(f12, svcsdktypes.Compatibility(f12elem))
		}
		res.RequiresCompatibilities = f12
	}
	if r.ko.Spec.RuntimePlatform != nil {
		f13 := &svcsdktypes.RuntimePlatform{}
		if r.ko.Spec.RuntimePlatform.CPUArchitecture != nil {
			f13.CpuArchitecture = svcsdktypes.CPUArchitecture(*r.ko.Spec.RuntimePlatform.CPUArchitecture)
		}
		if r.ko.Spec.RuntimePlatform.OperatingSystemFamily != nil {
			f13.OperatingSystemFamily = svcsdktypes.OSFamily(*r.ko.Spec.RuntimePlatform.OperatingSystemFamily)
		}
		res.RuntimePlatform = f13
	}
	if r.ko.Spec.Tags != nil {
		f14 := []svcsdktypes.Tag{}
		for _, f14iter := range r.ko.Spec.Tags {
			f14elem := &svcsdktypes.Tag{}
			if f14iter.Key != nil {
				f14elem.Key = f14iter.Key
			}
			if f14iter.Value != nil {
				f14elem.Value = f14iter.Value
			}
			f14 = append(f14, *f14elem)
		}
		res.Tags = f14
	}
	if r.ko.Spec.TaskRoleARN != nil {
		res.TaskRoleArn = r.ko.Spec.TaskRoleARN
	}
	if r.ko.Spec.Volumes != nil {
		f16 := []svcsdktypes.Volume{}
		for _, f16iter := range r.ko.Spec.Volumes {
			f16elem := &svcsdktypes.Volume{}
			if f16iter.ConfiguredAtLaunch != nil {
				f16elem.ConfiguredAtLaunch = f16iter.ConfiguredAtLaunch
			}
			if f16iter.DockerVolumeConfiguration != nil {
				f16elemf1 := &svcsdktypes.DockerVolumeConfiguration{}
				if f16iter.DockerVolumeConfiguration.Autoprovision != nil {
					f16elemf1.Autoprovision = f16iter.DockerVolumeConfiguration.Autoprovision
				}
				if f16iter.DockerVolumeConfiguration.Driver != nil {
					f16elemf1.Driver = f16iter.DockerVolumeConfiguration.Driver
				}
				if f16iter.DockerVolumeConfiguration.DriverOpts != nil {
					f16elemf1.DriverOpts = aws.ToStringMap(f16iter.DockerVolumeConfiguration.DriverOpts)
				}
				if f16iter.DockerVolumeConfiguration.Labels != nil {
					f16elemf1.Labels = aws.ToStringMap(f16iter.DockerVolumeConfiguration.Labels)
				}
				if f16iter.DockerVolumeConfiguration.Scope != nil {
					f16elemf1.Scope = svcsdktypes.Scope(*f16iter.DockerVolumeConfiguration.Scope)
				}
				f16elem.DockerVolumeConfiguration = f16elemf1
			}
			if f16iter.EFSVolumeConfiguration != nil {
				f16elemf2 := &svcsdktypes.EFSVolumeConfiguration{}
				if f16iter.EFSVolumeConfiguration.AuthorizationConfig != nil {
					f16elemf2f0 := &svcsdktypes.EFSAuthorizationConfig{}
					if f16iter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID != nil {
						f16elemf2f0.AccessPointId = f16iter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID
					}
					if f16iter.EFSVolumeConfiguration.AuthorizationConfig.IAM != nil {
						f16elemf2f0.Iam = svcsdktypes.EFSAuthorizationConfigIAM(*f16iter.EFSVolumeConfiguration.AuthorizationConfig.IAM)
					}
					f16elemf2.AuthorizationConfig = f16elemf2f0
				}
				if f16iter.EFSVolumeConfiguration.FileSystemID != nil {
					f16elemf2.FileSystemId = f16iter.EFSVolumeConfiguration.FileSystemID
				}
				if f16iter.EFSVolumeConfiguration.RootDirectory != nil {
					f16elemf2.RootDirectory = f16iter.EFSVolumeConfiguration.RootDirectory
				}
				if f16iter.EFSVolumeConfiguration.TransitEncryption != nil {
					f16elemf2.TransitEncryption = svcsdktypes.EFSTransitEncryption(*f16iter.EFSVolumeConfiguration.TransitEncryption)
				}
				if f16iter.EFSVolumeConfiguration.TransitEncryptionPort != nil {
					transitEncryptionPortCopy0 := *f16iter.EFSVolumeConfiguration.TransitEncryptionPort
					if transitEncryptionPortCopy0 > math.MaxInt32 || transitEncryptionPortCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field transitEncryptionPort is of type int32")
					}
					transitEncryptionPortCopy := int32(transitEncryptionPortCopy0)
					f16elemf2.TransitEncryptionPort = &transitEncryptionPortCopy
				}
				f16elem.EfsVolumeConfiguration = f16elemf2
			}
			if f16iter.FsxWindowsFileServerVolumeConfiguration != nil {
				f16elemf3 := &svcsdktypes.FSxWindowsFileServerVolumeConfiguration{}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
					f16elemf3f0 := &svcsdktypes.FSxWindowsFileServerAuthorizationConfig{}
					if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
						f16elemf3f0.CredentialsParameter = f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter
					}
					if f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
						f16elemf3f0.Domain = f16iter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain
					}
					f16elemf3.AuthorizationConfig = f16elemf3f0
				}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.FileSystemID != nil {
					f16elemf3.FileSystemId = f16iter.FsxWindowsFileServerVolumeConfiguration.FileSystemID
				}
				if f16iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
					f16elemf3.RootDirectory = f16iter.FsxWindowsFileServerVolumeConfiguration.RootDirectory
				}
				f16elem.FsxWindowsFileServerVolumeConfiguration = f16elemf3
			}
			if f16iter.Host != nil {
				f16elemf4 := &svcsdktypes.HostVolumeProperties{}
				if f16iter.Host.SourcePath != nil {
					f16elemf4.SourcePath = f16iter.Host.SourcePath
				}
				f16elem.Host = f16elemf4
			}
			if f16iter.Name != nil {
				f16elem.Name = f16iter.Name
			}
			f16 = append(f16, *f16elem)
		}
		res.Volumes = f16
	}

	return res, nil
}

// sdkDelete deletes the supplied resource in the backend AWS service API
func (rm *resourceManager) sdkDelete(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkDelete")
	defer func() {
		exit(err)
	}()
	input, err := rm.newDeleteRequestPayload(r)
	if err != nil {
		return nil, err
	}
	response, err := rm.sdkapi.ListTaskDefinitions(ctx, &svcsdk.ListTaskDefinitionsInput{
		FamilyPrefix: r.ko.Spec.Family,
	})
	if err != nil {
		return nil, err
	}

	for _, taskDefinitionArn := range response.TaskDefinitionArns {
		input := &svcsdk.DeregisterTaskDefinitionInput{
			TaskDefinition: &taskDefinitionArn,
		}
		_, err := rm.sdkapi.DeregisterTaskDefinition(ctx, input)
		rm.metrics.RecordAPICall("DELETE", "DeregisterTaskDefinition", err)
		if err != nil {
			return nil, err
		}
	}
	return nil, nil
	var resp *svcsdk.DeregisterTaskDefinitionOutput
	_ = resp
	resp, err = rm.sdkapi.DeregisterTaskDefinition(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "DeregisterTaskDefinition", err)
	return nil, err
}

// newDeleteRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Delete API call for the resource
func (rm *resourceManager) newDeleteRequestPayload(
	r *resource,
) (*svcsdk.DeregisterTaskDefinitionInput, error) {
	res := &svcsdk.DeregisterTaskDefinitionInput{}

	return res, nil
}

// setStatusDefaults sets default properties into supplied custom resource
func (rm *resourceManager) setStatusDefaults(
	ko *svcapitypes.TaskDefinition,
) {
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if ko.Status.ACKResourceMetadata.Region == nil {
		ko.Status.ACKResourceMetadata.Region = &rm.awsRegion
	}
	if ko.Status.ACKResourceMetadata.OwnerAccountID == nil {
		ko.Status.ACKResourceMetadata.OwnerAccountID = &rm.awsAccountID
	}
	if ko.Status.Conditions == nil {
		ko.Status.Conditions = []*ackv1alpha1.Condition{}
	}
}

// updateConditions returns updated resource, true; if conditions were updated
// else it returns nil, false
func (rm *resourceManager) updateConditions(
	r *resource,
	onSuccess bool,
	err error,
) (*resource, bool) {
	ko := r.ko.DeepCopy()
	rm.setStatusDefaults(ko)

	// Terminal condition
	var terminalCondition *ackv1alpha1.Condition = nil
	var recoverableCondition *ackv1alpha1.Condition = nil
	var syncCondition *ackv1alpha1.Condition = nil
	for _, condition := range ko.Status.Conditions {
		if condition.Type == ackv1alpha1.ConditionTypeTerminal {
			terminalCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeRecoverable {
			recoverableCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeResourceSynced {
			syncCondition = condition
		}
	}
	var termError *ackerr.TerminalError
	if rm.terminalAWSError(err) || err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
		if terminalCondition == nil {
			terminalCondition = &ackv1alpha1.Condition{
				Type: ackv1alpha1.ConditionTypeTerminal,
			}
			ko.Status.Conditions = append(ko.Status.Conditions, terminalCondition)
		}
		var errorMessage = ""
		if err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
			errorMessage = err.Error()
		} else {
			awsErr, _ := ackerr.AWSError(err)
			errorMessage = awsErr.Error()
		}
		terminalCondition.Status = corev1.ConditionTrue
		terminalCondition.Message = &errorMessage
	} else {
		// Clear the terminal condition if no longer present
		if terminalCondition != nil {
			terminalCondition.Status = corev1.ConditionFalse
			terminalCondition.Message = nil
		}
		// Handling Recoverable Conditions
		if err != nil {
			if recoverableCondition == nil {
				// Add a new Condition containing a non-terminal error
				recoverableCondition = &ackv1alpha1.Condition{
					Type: ackv1alpha1.ConditionTypeRecoverable,
				}
				ko.Status.Conditions = append(ko.Status.Conditions, recoverableCondition)
			}
			recoverableCondition.Status = corev1.ConditionTrue
			awsErr, _ := ackerr.AWSError(err)
			errorMessage := err.Error()
			if awsErr != nil {
				errorMessage = awsErr.Error()
			}
			recoverableCondition.Message = &errorMessage
		} else if recoverableCondition != nil {
			recoverableCondition.Status = corev1.ConditionFalse
			recoverableCondition.Message = nil
		}
	}
	// Required to avoid the "declared but not used" error in the default case
	_ = syncCondition
	if terminalCondition != nil || recoverableCondition != nil || syncCondition != nil {
		return &resource{ko}, true // updated
	}
	return nil, false // not updated
}

// terminalAWSError returns awserr, true; if the supplied error is an aws Error type
// and if the exception indicates that it is a Terminal exception
// 'Terminal' exception are specified in generator configuration
func (rm *resourceManager) terminalAWSError(err error) bool {
	if err == nil {
		return false
	}

	var terminalErr smithy.APIError
	if !errors.As(err, &terminalErr) {
		return false
	}
	switch terminalErr.ErrorCode() {
	case "InvalidParameterException":
		return true
	default:
		return false
	}
}
