// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ServiceSpec defines the desired state of Service.
//
// Details on a service within a cluster.
type ServiceSpec struct {

	// The capacity provider strategy to use for the service.
	//
	// If a capacityProviderStrategy is specified, the launchType parameter must
	// be omitted. If no capacityProviderStrategy or launchType is specified, the
	// defaultCapacityProviderStrategy for the cluster is used.
	//
	// A capacity provider strategy may contain a maximum of 6 capacity providers.
	CapacityProviderStrategy []*CapacityProviderStrategyItem `json:"capacityProviderStrategy,omitempty"`
	// The short name or full Amazon Resource Name (ARN) of the cluster that you
	// run your service on. If you do not specify a cluster, the default cluster
	// is assumed.
	Cluster    *string                                  `json:"cluster,omitempty"`
	ClusterRef *ackv1alpha1.AWSResourceReferenceWrapper `json:"clusterRef,omitempty"`
	// Optional deployment parameters that control how many tasks run during the
	// deployment and the ordering of stopping and starting tasks.
	DeploymentConfiguration *DeploymentConfiguration `json:"deploymentConfiguration,omitempty"`
	// The deployment controller to use for the service. If no deployment controller
	// is specified, the default value of ECS is used.
	DeploymentController *DeploymentController `json:"deploymentController,omitempty"`
	// The number of instantiations of the specified task definition to place and
	// keep running in your service.
	//
	// This is required if schedulingStrategy is REPLICA or isn't specified. If
	// schedulingStrategy is DAEMON then this isn't required.
	DesiredCount *int64 `json:"desiredCount,omitempty"`
	// Specifies whether to turn on Amazon ECS managed tags for the tasks within
	// the service. For more information, see Tagging your Amazon ECS resources
	// (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// When you use Amazon ECS managed tags, you need to set the propagateTags request
	// parameter.
	EnableECSManagedTags *bool `json:"enableECSManagedTags,omitempty"`
	// Determines whether the execute command functionality is turned on for the
	// service. If true, this enables execute command functionality on all containers
	// in the service tasks.
	EnableExecuteCommand *bool `json:"enableExecuteCommand,omitempty"`
	// The period of time, in seconds, that the Amazon ECS service scheduler ignores
	// unhealthy Elastic Load Balancing, VPC Lattice, and container health checks
	// after a task has first started. If you don't specify a health check grace
	// period value, the default value of 0 is used. If you don't use any of the
	// health checks, then healthCheckGracePeriodSeconds is unused.
	//
	// If your service's tasks take a while to start and respond to health checks,
	// you can specify a health check grace period of up to 2,147,483,647 seconds
	// (about 69 years). During that time, the Amazon ECS service scheduler ignores
	// health check status. This grace period can prevent the service scheduler
	// from marking tasks as unhealthy and stopping them before they have time to
	// come up.
	HealthCheckGracePeriodSeconds *int64 `json:"healthCheckGracePeriodSeconds,omitempty"`
	// The infrastructure that you run your service on. For more information, see
	// Amazon ECS launch types (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// The FARGATE launch type runs your tasks on Fargate On-Demand infrastructure.
	//
	// Fargate Spot infrastructure is available for use but a capacity provider
	// strategy must be used. For more information, see Fargate capacity providers
	// (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/fargate-capacity-providers.html)
	// in the Amazon ECS Developer Guide.
	//
	// The EC2 launch type runs your tasks on Amazon EC2 instances registered to
	// your cluster.
	//
	// The EXTERNAL launch type runs your tasks on your on-premises server or virtual
	// machine (VM) capacity registered to your cluster.
	//
	// A service can use either a launch type or a capacity provider strategy. If
	// a launchType is specified, the capacityProviderStrategy parameter must be
	// omitted.
	LaunchType *string `json:"launchType,omitempty"`
	// A load balancer object representing the load balancers to use with your service.
	// For more information, see Service load balancing (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// If the service uses the rolling update (ECS) deployment controller and using
	// either an Application Load Balancer or Network Load Balancer, you must specify
	// one or more target group ARNs to attach to the service. The service-linked
	// role is required for services that use multiple target groups. For more information,
	// see Using service-linked roles for Amazon ECS (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// If the service uses the CODE_DEPLOY deployment controller, the service is
	// required to use either an Application Load Balancer or Network Load Balancer.
	// When creating an CodeDeploy deployment group, you specify two target groups
	// (referred to as a targetGroupPair). During a deployment, CodeDeploy determines
	// which task set in your service has the status PRIMARY, and it associates
	// one target group with it. Then, it also associates the other target group
	// with the replacement task set. The load balancer can also have up to two
	// listeners: a required listener for production traffic and an optional listener
	// that you can use to perform validation tests with Lambda functions before
	// routing production traffic to it.
	//
	// If you use the CODE_DEPLOY deployment controller, these values can be changed
	// when updating the service.
	//
	// For Application Load Balancers and Network Load Balancers, this object must
	// contain the load balancer target group ARN, the container name, and the container
	// port to access from the load balancer. The container name must be as it appears
	// in a container definition. The load balancer name parameter must be omitted.
	// When a task from this service is placed on a container instance, the container
	// instance and port combination is registered as a target in the target group
	// that's specified here.
	//
	// For Classic Load Balancers, this object must contain the load balancer name,
	// the container name , and the container port to access from the load balancer.
	// The container name must be as it appears in a container definition. The target
	// group ARN parameter must be omitted. When a task from this service is placed
	// on a container instance, the container instance is registered with the load
	// balancer that's specified here.
	//
	// Services with tasks that use the awsvpc network mode (for example, those
	// with the Fargate launch type) only support Application Load Balancers and
	// Network Load Balancers. Classic Load Balancers aren't supported. Also, when
	// you create any target groups for these services, you must choose ip as the
	// target type, not instance. This is because tasks that use the awsvpc network
	// mode are associated with an elastic network interface, not an Amazon EC2
	// instance.
	LoadBalancers []*LoadBalancer `json:"loadBalancers,omitempty"`
	// The name of your service. Up to 255 letters (uppercase and lowercase), numbers,
	// underscores, and hyphens are allowed. Service names must be unique within
	// a cluster, but you can have similarly named services in multiple clusters
	// within a Region or across multiple Regions.
	// +kubebuilder:validation:Required
	Name *string `json:"name"`
	// The network configuration for the service. This parameter is required for
	// task definitions that use the awsvpc network mode to receive their own elastic
	// network interface, and it isn't supported for other network modes. For more
	// information, see Task networking (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
	// in the Amazon Elastic Container Service Developer Guide.
	NetworkConfiguration *NetworkConfiguration `json:"networkConfiguration,omitempty"`
	// An array of placement constraint objects to use for tasks in your service.
	// You can specify a maximum of 10 constraints for each task. This limit includes
	// constraints in the task definition and those specified at runtime.
	PlacementConstraints []*PlacementConstraint `json:"placementConstraints,omitempty"`
	// The placement strategy objects to use for tasks in your service. You can
	// specify a maximum of 5 strategy rules for each service.
	PlacementStrategy []*PlacementStrategy `json:"placementStrategy,omitempty"`
	// The platform version that your tasks in the service are running on. A platform
	// version is specified only for tasks using the Fargate launch type. If one
	// isn't specified, the LATEST platform version is used. For more information,
	// see Fargate platform versions (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html)
	// in the Amazon Elastic Container Service Developer Guide.
	PlatformVersion *string `json:"platformVersion,omitempty"`
	// Specifies whether to propagate the tags from the task definition to the task.
	// If no value is specified, the tags aren't propagated. Tags can only be propagated
	// to the task during task creation. To add tags to a task after task creation,
	// use the TagResource (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html)
	// API action.
	//
	// You must set this to a value other than NONE when you use Cost Explorer.
	// For more information, see Amazon ECS usage reports (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/usage-reports.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// The default is NONE.
	PropagateTags *string `json:"propagateTags,omitempty"`
	// The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon
	// ECS to make calls to your load balancer on your behalf. This parameter is
	// only permitted if you are using a load balancer with your service and your
	// task definition doesn't use the awsvpc network mode. If you specify the role
	// parameter, you must also specify a load balancer object with the loadBalancers
	// parameter.
	//
	// If your account has already created the Amazon ECS service-linked role, that
	// role is used for your service unless you specify a role here. The service-linked
	// role is required if your task definition uses the awsvpc network mode or
	// if the service is configured to use service discovery, an external deployment
	// controller, multiple target groups, or Elastic Inference accelerators in
	// which case you don't specify a role here. For more information, see Using
	// service-linked roles for Amazon ECS (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html)
	// in the Amazon Elastic Container Service Developer Guide.
	//
	// If your specified role has a path other than /, then you must either specify
	// the full role ARN (this is recommended) or prefix the role name with the
	// path. For example, if a role with the name bar has a path of /foo/ then you
	// would specify /foo/bar as the role name. For more information, see Friendly
	// names and paths (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names)
	// in the IAM User Guide.
	Role    *string                                  `json:"role,omitempty"`
	RoleRef *ackv1alpha1.AWSResourceReferenceWrapper `json:"roleRef,omitempty"`
	// The scheduling strategy to use for the service. For more information, see
	// Services (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html).
	//
	// There are two service scheduler strategies available:
	//
	//   - REPLICA-The replica scheduling strategy places and maintains the desired
	//     number of tasks across your cluster. By default, the service scheduler
	//     spreads tasks across Availability Zones. You can use task placement strategies
	//     and constraints to customize task placement decisions. This scheduler
	//     strategy is required if the service uses the CODE_DEPLOY or EXTERNAL deployment
	//     controller types.
	//
	//   - DAEMON-The daemon scheduling strategy deploys exactly one task on each
	//     active container instance that meets all of the task placement constraints
	//     that you specify in your cluster. The service scheduler also evaluates
	//     the task placement constraints for running tasks and will stop tasks that
	//     don't meet the placement constraints. When you're using this strategy,
	//     you don't need to specify a desired number of tasks, a task placement
	//     strategy, or use Service Auto Scaling policies. Tasks using the Fargate
	//     launch type or the CODE_DEPLOY or EXTERNAL deployment controller types
	//     don't support the DAEMON scheduling strategy.
	SchedulingStrategy *string `json:"schedulingStrategy,omitempty"`
	// The configuration for this service to discover and connect to services, and
	// be discovered by, and connected from, other services within a namespace.
	//
	// Tasks that run in a namespace can use short names to connect to services
	// in the namespace. Tasks can connect to services across all of the clusters
	// in the namespace. Tasks connect through a managed proxy container that collects
	// logs and metrics for increased visibility. Only the tasks that Amazon ECS
	// services create are supported with Service Connect. For more information,
	// see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html)
	// in the Amazon Elastic Container Service Developer Guide.
	ServiceConnectConfiguration *ServiceConnectConfiguration `json:"serviceConnectConfiguration,omitempty"`
	// The details of the service discovery registry to associate with this service.
	// For more information, see Service discovery (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html).
	//
	// Each service may be associated with one service registry. Multiple service
	// registries for each service isn't supported.
	ServiceRegistries []*ServiceRegistry `json:"serviceRegistries,omitempty"`
	// The metadata that you apply to the service to help you categorize and organize
	// them. Each tag consists of a key and an optional value, both of which you
	// define. When a service is deleted, the tags are deleted as well.
	//
	// The following basic restrictions apply to tags:
	//
	//   - Maximum number of tags per resource - 50
	//
	//   - For each resource, each tag key must be unique, and each tag key can
	//     have only one value.
	//
	//   - Maximum key length - 128 Unicode characters in UTF-8
	//
	//   - Maximum value length - 256 Unicode characters in UTF-8
	//
	//   - If your tagging schema is used across multiple services and resources,
	//     remember that other services may have restrictions on allowed characters.
	//     Generally allowed characters are: letters, numbers, and spaces representable
	//     in UTF-8, and the following characters: + - = . _ : / @.
	//
	//   - Tag keys and values are case-sensitive.
	//
	//   - Do not use aws:, AWS:, or any upper or lowercase combination of such
	//     as a prefix for either keys or values as it is reserved for Amazon Web
	//     Services use. You cannot edit or delete tag keys or values with this prefix.
	//     Tags with this prefix do not count against your tags per resource limit.
	Tags []*Tag `json:"tags,omitempty"`
	// The family and revision (family:revision) or full ARN of the task definition
	// to run in your service. If a revision isn't specified, the latest ACTIVE
	// revision is used.
	//
	// A task definition must be specified if the service uses either the ECS or
	// CODE_DEPLOY deployment controllers.
	//
	// For more information about deployment types, see Amazon ECS deployment types
	// (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
	TaskDefinition    *string                                  `json:"taskDefinition,omitempty"`
	TaskDefinitionRef *ackv1alpha1.AWSResourceReferenceWrapper `json:"taskDefinitionRef,omitempty"`
	// The configuration for a volume specified in the task definition as a volume
	// that is configured at launch time. Currently, the only supported volume type
	// is an Amazon EBS volume.
	VolumeConfigurations []*ServiceVolumeConfiguration `json:"volumeConfigurations,omitempty"`
}

// ServiceStatus defines the observed state of Service
type ServiceStatus struct {
	// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
	// that is used to contain resource sync state, account ownership,
	// constructed ARN for the resource
	// +kubebuilder:validation:Optional
	ACKResourceMetadata *ackv1alpha1.ResourceMetadata `json:"ackResourceMetadata"`
	// All CRs managed by ACK have a common `Status.Conditions` member that
	// contains a collection of `ackv1alpha1.Condition` objects that describe
	// the various terminal states of the CR and its backend AWS service API
	// resource
	// +kubebuilder:validation:Optional
	Conditions []*ackv1alpha1.Condition `json:"conditions"`
	// The Amazon Resource Name (ARN) of the cluster that hosts the service.
	// +kubebuilder:validation:Optional
	ClusterARN *string `json:"clusterARN,omitempty"`
	// The Unix timestamp for the time when the service was created.
	// +kubebuilder:validation:Optional
	CreatedAt *metav1.Time `json:"createdAt,omitempty"`
	// The principal that created the service.
	// +kubebuilder:validation:Optional
	CreatedBy *string `json:"createdBy,omitempty"`
	// The current state of deployments for the service.
	// +kubebuilder:validation:Optional
	Deployments []*Deployment `json:"deployments,omitempty"`
	// The event stream for your service. A maximum of 100 of the latest events
	// are displayed.
	// +kubebuilder:validation:Optional
	Events []*ServiceEvent `json:"events,omitempty"`
	// The number of tasks in the cluster that are in the PENDING state.
	// +kubebuilder:validation:Optional
	PendingCount *int64 `json:"pendingCount,omitempty"`
	// The operating system that your tasks in the service run on. A platform family
	// is specified only for tasks using the Fargate launch type.
	//
	// All tasks that run as part of this service must use the same platformFamily
	// value as the service (for example, LINUX).
	// +kubebuilder:validation:Optional
	PlatformFamily *string `json:"platformFamily,omitempty"`
	// The ARN of the IAM role that's associated with the service. It allows the
	// Amazon ECS container agent to register container instances with an Elastic
	// Load Balancing load balancer.
	// +kubebuilder:validation:Optional
	RoleARN *string `json:"roleARN,omitempty"`
	// The number of tasks in the cluster that are in the RUNNING state.
	// +kubebuilder:validation:Optional
	RunningCount *int64 `json:"runningCount,omitempty"`
	// The status of the service. The valid values are ACTIVE, DRAINING, or INACTIVE.
	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty"`
	// Information about a set of Amazon ECS tasks in either an CodeDeploy or an
	// EXTERNAL deployment. An Amazon ECS task set includes details such as the
	// desired number of tasks, how many tasks are running, and whether the task
	// set serves production traffic.
	// +kubebuilder:validation:Optional
	TaskSets []*TaskSet `json:"taskSets,omitempty"`
}

// Service is the Schema for the Services API
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="CLUSTER",type=string,priority=0,JSONPath=`.spec.cluster`
// +kubebuilder:printcolumn:name="DESIRED",type=integer,priority=0,JSONPath=`.spec.desiredCount`
// +kubebuilder:printcolumn:name="PENDING",type=integer,priority=0,JSONPath=`.status.pendingCount`
// +kubebuilder:printcolumn:name="RUNNING",type=integer,priority=0,JSONPath=`.status.runningCount`
// +kubebuilder:printcolumn:name="SERVICE",type=string,priority=0,JSONPath=`.spec.name`
// +kubebuilder:printcolumn:name="STATUS",type=string,priority=0,JSONPath=`.status.status`
// +kubebuilder:printcolumn:name="TASKDEFINITION",type=string,priority=0,JSONPath=`.spec.taskDefinition`
type Service struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServiceSpec   `json:"spec,omitempty"`
	Status            ServiceStatus `json:"status,omitempty"`
}

// ServiceList contains a list of Service
// +kubebuilder:object:root=true
type ServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Service `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Service{}, &ServiceList{})
}
